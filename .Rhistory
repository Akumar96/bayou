irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
#t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
})
system.time( for(i in 1:500){
nbranch <- length(cache$edge.length)
nshifts <- table(pars$sb)
shifts <- rep(0,nbranch)
shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
#t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
})
system.time( for(i in 1:500){
nbranch <- length(cache$edge.length)
nshifts <- table(pars$sb)
shifts <- rep(0,nbranch)
#shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
})
system.time( for(i in 1:500){
nbranch <- length(cache$edge.length)
nshifts <- table(pars$sb)
#shifts <- rep(0,nbranch)
#shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
})
shifts <- rep(0,nbranch)
shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
nbranch <- length(cache$edge.length)
nshifts <- table(pars$sb)
shifts <- rep(0,nbranch)
shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
system.time( for(i in 1:500){
nbranch <- length(cache$edge.length)
nshifts <- table(pars$sb)
#shifts <- rep(0,nbranch)
#shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
#irow <- rep(1:nbranch,shifts+1)
csbase <- cache$nH[irow]
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
csmaps <- csadd + csbase
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
})
sapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]]))
lapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]]),F,F)
?lapply
unlist(lapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
system.time(for(i in 1:500){
sandwiches <- unlist(lapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
})
system.time(for(i in 1:500){
#sandwiches <- unlist(lapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
sandwiches <- sapply(1:length(pars$sb), function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]]))
})
length(pars$sb)
pars$k
system.time(for(i in 1:500){
sandwiches <- unlist(lapply(1:pars$k, function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
})
system.time(for(i in 1:500){
sandwiches <- unlist(lapply(1:pars$k, function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
})
duplicated(pars$sb[order(pars$loc)])
order(pars$loc)
order(pars$loc)[duplicated(pars$sb[order(pars$loc)])]
sandwiches
sandwiches <- unlist(lapply(1:pars$k, function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
sandwiches
order(pars$loc)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
sandwiches==order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
sandwiches
order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
sandwiches[order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]\
sandwiches[order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]]
system.time(for(i in 1:500){
sandwiches <- unlist(lapply(1:pars$k, function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
#sandwiches <- order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
})
system.time(for(i in 1:500){
#sandwiches <- unlist(lapply(1:pars$k, function(x) pars$loc[x] != max(pars$loc[pars$sb == pars$sb[x]])),F,F)
sandwiches <- order(pars$loc,decreasing=TRUE)[duplicated(pars$sb[order(pars$loc,decreasing=TRUE)])]
})
tmp.o <- order(pars$loc,decreasing=TRUE)
sandwiches <- tmp.o[duplicated(pars$sb[tmp.o])]
sandwiches
system.time(for(i in 1:500){
tmp.o <- order(pars$loc,decreasing=TRUE)
sandwiches <- tmp.o[duplicated(pars$sb[tmp.o])]
})
system.time(for(i in 1:500){
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
tmp.o <- order(pars$loc,decreasing=TRUE)
})
#We need to know what the ending theta is for each segment, so we sort pars$t2 as we did for pars$loc, but +1 because t2 is the ending regime
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
#Now we need to cascade these regime down the tree. We won't need to cascade sandwiches, as they are trapped on the branch they occur. So we find them below:
tmp.o <- order(pars$loc,decreasing=TRUE)
sandwiches <- tmp.o[duplicated(pars$sb[tmp.o])]
#And remove them:
sb.down <- pars$sb[-sandwiches]
t2.down <- pars$t2[-sandwiches]
sb.down
sb.o <- order(sb.down)
sb.down <- sb.down[sb.o]
t2.down <- t2.down[sb.o]
sb.down
sb.down
system.time(for(i in 1:500){
sb.desc <- lapply(sb.down, function(x) cache$bdesc[[x]])
})
cache$bdesc[sb.down]==sb.desc
cache$bdesc[sb.down]
sb.desc
system.time(for(i in 1:500){
#cache$bdesc[sb.down]
sb.desc <- lapply(sb.down, function(x) cache$bdesc[[x]])
})
system.time(for(i in 1:500){
cache$bdesc[sb.down]
#sb.desc <- lapply(sb.down, function(x) cache$bdesc[[x]])
})
names(csmaps)
tmp.o
nbranch <- length(cache$edge.length)
#create a vector called shifts that indicates the number of shifts for each branch
nshifts <- table(pars$sb)
shifts <- rep(0,nbranch)
shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
#Create an index equal to the number of segments that identifies the branch on which each segment is found
irow <- rep(1:nbranch,shifts+1)
#For now, starting height is just the height of the node
csbase <- cache$nH[irow]
#Calculate the ending height by sorting the edge.length and the location of shifts by their branch identity and location
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
#Ending height of the segment
csmaps <- csadd + csbase
#We need to know what the ending theta is for each segment, so we sort pars$t2 as we did for pars$loc, but +1 because t2 is the ending regime
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
#Now we need to cascade these regime down the tree. We won't need to cascade sandwiches, as they are trapped on the branch they occur. So we find them below:
loc.o <- order(pars$loc,decreasing=TRUE)
sandwiches <- tmp.o[duplicated(pars$sb[loc.o])]
#And remove them:
sb.down <- pars$sb[-sandwiches]
t2.down <- pars$t2[-sandwiches]
#Now we order the sb's and t2's to prepare for a postorder tree traversal
sb.o <- order(sb.down)
sb.down <- sb.down[sb.o]
t2.down <- t2.down[sb.o]
sb.desc <- cache$bdesc[sb.down]
#Loop traveling down the tree, saving all descendents that are from that shift into the vector censored. These branches cannot be modified by shifts further down the tree.
censored <- NULL
names(t2b) <- names(csmaps)
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
sb.desc[[i]] <- sb.desc[[i]][-length(sb.desc[[i]])]
censored <- c(censored, sb.desc[[i]])
t2b[names(csmaps)[names(csmaps) %in% sb.desc[[i]]]] <- t2.down[i]
}
names(csmaps)
add.o
system.time(for(j in 1:100){
censored <- NULL
names(t2b) <- names(csmaps)
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
sb.desc[[i]] <- sb.desc[[i]][-length(sb.desc[[i]])]
censored <- c(censored, sb.desc[[i]])
t2b[names(csmaps)[names(csmaps) %in% sb.desc[[i]]]] <- t2.down[i]
}
})
system.time(for(j in 1:100){
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
sb.desc[[i]] <- sb.desc[[i]][-length(sb.desc[[i]])]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
})
name.o
name.o[name.o %in% sb.desc[[i]]]
system.time(for(j in 1:100){
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
sb.desc[[i]] <- sb.desc[[i]][-length(sb.desc[[i]])]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
})
load_all()
cache <- .prepare.ou.univariate(tree, dat)
cache <- .prepare.ou.univariate(tree, datRdat)
dat <- chelonia.simmap$dat
cache <- .prepare.ou.univariate(tree, dat)
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
system.time(for(i in 1:500){
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
})
names(csmaps) <- t2b
names(csmaps2)
names(csmaps2)==t2b
system.time(for(i in 1:1000){
if(length(index)>length(unique(index)))
x<-1
})
str(index)
attributes(index)
dim(index)
length(index)
nbranch+pars$sb
nbranch+pars$k
length(unique(index))
system.time(for(i in 1:1000){
if(nbranch+pars$k>length(unique(index)))
x<-1 })
system.time(for(i in 1:1000){
if(nbranch+pars$k>length(unique(index)))
x<-1 })
system.time(for(i in 1:1000){
if(nbranch+pars$k>length(unique(index)))
x<-1 })
index
system.time(for(i in 1:1000){
if(nbranch+pars$k>length(unique(as.data.frame(index))))
x<-1 })
system.time(for(i in 1:1000){
if(nbranch+pars$k>length(unique(index)))
x<-1 })
any(duplicated(index))
system.time(for(i in 1:1000){
#if(nbranch+pars$k>length(unique(index)))
if(any(duplicated(index)))
x<-1 })
system.time(for(i in 1:10000){
#if(nbranch+pars$k>length(unique(index)))
if(any(duplicated(index)))
x<-1 })
system.time(for(i in 1:10000){
if(nbranch+pars$k>length(unique(index)))
#if(any(duplicated(index)))
x<-1 })
load_all()
data(chelonia.simmap)
tree <- chelonia.simmap$tree
dat <- chelonia.simmap$dat
emap <- chelonia.simmap$emap
cache <- .prepare.ou.univariate(tree, dat)
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
dat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:500) .parmap.W(startpar, cache))
system.time(for(i in 1:500){.simmap.W(cache, startpar)})
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
4.316*1000000
4.316*1000000/60/60
4.316*1000000/60/60/24
tree <- sim.bdtree(n=100,stop="taxa")
tree <- sim.bdtree(n=64,stop="taxa")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
tree$edge.length
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
tree <- reorder.phylo(tree,"postorder")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
dat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
tree <- sim.bdtree(n=64,stop="taxa")
tree <- reorder.phylo(tree,"postorder")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
simdat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache <- .prepare.ou.univariate(tree, simdat$dat)
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
tree <- sim.bdtree(n=32,stop="taxa")
tree <- reorder.phylo(tree,"postorder")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
simdat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache <- .prepare.ou.univariate(tree, simdat$dat)
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
tree <- sim.bdtree(n=64,stop="taxa")
tree <- reorder.phylo(tree,"postorder")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
simdat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache <- .prepare.ou.univariate(tree, simdat$dat)
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
tree <- sim.bdtree(n=1000,stop="taxa")
tree <- reorder.phylo(tree,"postorder")
prior <- make.prior(tree,model="OU",dists=list(dk="dnbinom"),param=list(dk=list(size=1,prob=0.02),dsb=list(bmax=Inf,prob=tree$edge.length)),type="pars",plot.prior=TRUE)
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
simdat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache <- .prepare.ou.univariate(tree, simdat$dat)
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:10) .parmap.W(startpar, cache))
system.time(for(i in 1:10) .simmap.W(cache, startpar))
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
startpar$sb <- startpar$loc <-startpar$t2 <- NULL
.parmap.W(startpar, cache)
startpar$theta <-startpar$theta[1]
startpar$k=0
startpar$ntheta=1
.parmap.W(startpar, cache)
cache$ntips
W
load_all()
Rprof()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
summaryRprof()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
pars$k
startpar$k
load_all()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
rm(.parmap.W)
load_all()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
Rprof()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
summaryRprof()
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
startpar <- priorSim(prior,tree,plot=TRUE,nsim=1,exclude.branches=NULL, ftype="off",pts=F)$pars[[1]]
mapped.tree <- pars2simmap(startpar,tree,sim.theta=FALSE,theta=startpar$theta,root.theta=startpar$theta[1])
plotSimmap(mapped.tree$tree,col=mapped.tree$col,ftype="off",pts=F)
simdat<-dataSim(startpar,"OU",tree,map.type="pars",phenogram=TRUE,ftype="off")
cache <- .prepare.ou.univariate(tree, simdat$dat)
cache$maps <- mapped.tree$tree$maps
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
system.time(for(i in 1:1000) .simmap.W(cache, startpar))
Rprof()
system.time(for(i in 1:1000) .parmap.W(startpar, cache))
summaryRprof()
!(sb.desc[[i]] %in% censored)
nbranch <- length(cache$edge.length)
#create a vector called shifts that indicates the number of shifts for each branch
nshifts <- table(pars$sb)
shifts <- rep(0,nbranch)
shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts
#Create an index equal to the number of segments that identifies the branch on which each segment is found
irow <- rep(1:nbranch,shifts+1)
#For now, starting height is just the height of the node
csbase <- cache$nH[irow]
#Calculate the ending height by sorting the edge.length and the location of shifts by their branch identity and location
csadd <- c(tree$edge.length, pars$loc)
tmp.o <- c(1:nbranch, pars$sb)
names(csadd) <- tmp.o
add.o <- order(tmp.o,csadd)
csadd <- csadd[add.o]
#Ending height of the segment
csmaps <- csadd + csbase
#We need to know what the ending theta is for each segment, so we sort pars$t2 as we did for pars$loc, but +1 because t2 is the ending regime
t2index <- add.o[which(add.o > nbranch)]
t2b <- c(rep(1,length(csmaps)))
t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]
#Now we need to cascade these regime down the tree. We won't need to cascade sandwiches, as they are trapped on the branch they occur. So we find them below:
loc.o <- order(pars$loc,decreasing=TRUE)
sandwiches <- tmp.o[duplicated(pars$sb[loc.o])]
# And remove them:
sb.down <- pars$sb[-sandwiches]
t2.down <- pars$t2[-sandwiches]
#Now we order the sb's and t2's to prepare for a postorder tree traversal
sb.o <- order(sb.down)
sb.down <- sb.down[sb.o]
t2.down <- t2.down[sb.o]
sb.desc <- cache$bdesc[sb.down]
#Loop traveling down the tree, saving all descendents that are from that shift into the vector censored. These branches cannot be modified by shifts further down the tree.
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
i=1
for(i in 1:length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
i
for(i in 1:25){#length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- NULL
name.o <- names(csmaps)
names(t2b) <- name.o
for(i in 1:25){#length(sb.desc)){
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
}
i=26
sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]
censored <- c(censored, sb.desc[[i]])
t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]
i=27
sb.desc[[i]]
sb.desc[[28]]
sb.desc[[29]]
censored
