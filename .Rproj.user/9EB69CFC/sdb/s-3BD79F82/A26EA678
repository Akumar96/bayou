{
    "contents" : "#' Conditional Poisson distribution\n#' \n#' \\code{cdpois} calculates the probability density of a value \\code{k} from a Poisson distribution with a maximum \\code{kmax}. \\code{rdpois} draws random numbers from a conditional Poisson distribution.\n#' \n#' @rdname cdpois\n#' @param k random variable value\n#' @param n number of samples to draw\n#' @param kmax maximum value of the conditional Poisson distribution\n#' @param log log transformed density\n#' @param lambda rate parameter of the Poisson distribution\n#' @param ... additional parameters passed to \\code{dpois} or \\code{rpois}\n#' @export\n#' @examples\n#' cdpois(10,1,10)\n#' cdpois(11,1,10)\n#' rdpois(5,10,10)\ncdpois <- function(k,lambda,kmax,log=TRUE){\n  if(kmax < lambda) stop(\"lambda is too high relative to kmax\")\n  kmax <- ceiling(kmax)\n  i <- 0:kmax\n  R <- sum(dpois(i,lambda))\n  if(k<=kmax){\n    num <- dpois(k,lambda)\n  } else {num <- 0}\n  if(log){\n    log(num/R)\n  } else {num/R }\n}\n#' @rdname cdpois\nrdpois <- function(n,lambda,kmax,...){\n  kmax <- ceiling(kmax)\n  i=rep(kmax+1,n)\n  j=0\n  while(any(i>kmax)){\n    i[i>kmax] <- rpois(sum(i>kmax),lambda)\n    j <- j+1\n    if(j>100){stop (\"Lambda too high relative to kmax\")}\n  }\n  return(i)\n}\n\ndsb <- function(sb, ntips=ntips, bmax=1, prob=1, log=TRUE){\n  if(any(!(bmax %in% c(0,1,Inf)))) stop(\"Number of shifts allowed per branch must be 0, 1, or Inf\") \n  if(length(bmax)==1) bmax <- rep(bmax, 2*ntips-2)\n  if(length(bmax)!=(2*ntips-2)) stop (\"bmax not a multiple of the number of branches\")\n  sbt <- table(sb)\n  if(any(sbt > bmax[as.numeric(names(sbt))])){\n    dens <- 0\n    if(log) return(log(0)) else 0\n  } else {\n    if(max(bmax)==1){\n      if(length(prob)>1) warning(\"cannot sample unequal probabilities without replacement, assuming equal probabilities for each branch\")\n      dens <- 1/choose(sum(bmax),sum(sbt))\n      if(log) return(log(dens)) else return(dens)\n    } else {\n      if(any(!(bmax %in% c(0,Inf)))) stop(\"Cannot sample unequal probabilities without replacement\")\n      if(length(prob)==1) prob <- rep(1,2*ntips-2)\n      if(length(prob)!=2*ntips-2) stop(\"Number of probabilities provided must equal number of branches\")  \n      prob[bmax==0] <- 0\n      sbp.all <- prob/sum(prob)\n      sbp <- c(sbp.all[as.numeric(names(sbt))],1-sum(sbp.all[as.numeric(names(sbt))]))\n      if(log) return(dmultinom(c(sbt,0),prob=sbp,log=TRUE)) else return(dmultinom(c(sbt,0),prob=sbp))\n    }\n  }    \n}\n\nrsb <- function(k, ntips=ntips, bmax=1, prob=1, log=TRUE){\n  if(any(!(bmax %in% c(0,1,Inf)))) stop(\"Number of shifts allowed per branch must be 0, 1, or Inf\") \n  if(length(bmax)==1) bmax <- rep(bmax, 2*ntips-2)\n  if(length(bmax)!=(2*ntips-2)) stop (\"bmax not a multiple of the number of branches\")\n  if(max(bmax)==1){\n    if(length(prob)>1) warning(\"cannot sample unequal probabilities without replacement, assuming equal probabilities for each branch\")\n    sb <- .sample((1:(2*ntips-2))[bmax==1], k, replace=FALSE)\n    return(sb)\n  } else {\n    if(any(!(bmax %in% c(0,Inf)))) stop(\"Cannot sample unequal probabilities without replacement\")\n    if(length(prob)==1) prob <- rep(1,2*ntips-2)\n    if(length(prob)!=2*ntips-2) stop(\"Number of probabilities provided must equal number of branches\")  \n    prob[bmax==0] <- 0\n    sbp.all <- prob/sum(prob)\n    sb <- suppressWarnings(.sample((1:(2*ntips-2)), k, prob=sbp.all, replace=TRUE))\n    return(sb)\n  }\n}    \n  \n\n\ndsb.equal <- function(sb,ntips=ntips,log=TRUE){\n  if(log){\n    return(log(1/choose(2*ntips-2,length(sb))))\n  } else {return(1/choose(2*ntips-2,length(sb)))}\n}\ndsb.equalnotips <- function(sb,ntips=ntips,log=TRUE){\n  if(log){\n    return(log(1/choose(ntips-2,length(sb))))\n  } else {return(1/choose(ntips-2,length(sb)))}\n}\ndsb.free <- function(sb,ntips=ntips,edge.length=edge.length,log=TRUE){\n  dd <- tapply(sb,sb,length)\n  nd <- unique(sb)\n  pd <- edge.length[nd]/sum(edge.length)\n  dmultinom(c(dd,0),prob=c(pd,1-sum(pd)),log=log)\n} \n\nrsb.equal <- function(k, ntips=ntips, exclude.branches=NULL){\n  if(!is.null(exclude.branches)){\n    br <- (1:(2*ntips-2))[-c(exclude.branches)]\n  }\n  return(.sample(1:(2*ntips-2),k,replace=FALSE))\n}\nrsb.equalnotips <- function(k, ntips=ntips, tree=tree, exclude.branches=NULL){\n  if(!is.null(exclude.branches)){\n    exclude.branches <- c(exclude.branches,tree$edge[,2]<=ntips)\n  } else {\n    exclude.branches <- which(tree$edge[,2]<=ntips)\n  }\n  br <- (1:(2*ntips-2))[-c(exclude.branches)]\n  return(.sample(br,k,replace=FALSE))\n}\nrsb.free <- function(k, ntips=ntips, edge.length=edge.length, exclude.branches=NULL){\n  if(!is.null(exclude.branches)){\n    br <- (1:(2*ntips-2))[-c(exclude.branches)]\n    edge.length <- edge.length[-c(exclude.branches)]\n  } else {br <- (1:(2*ntips-2))}\n  prb <- edge.length/sum(edge.length)\n  sb <- suppressWarnings(.sample(br,k,prob=prb, replace=TRUE))\n  return(sb)\n}\n\ndloc <- function(loc,min=0,max=1,log=TRUE) if(log) return (rep(0,length(loc))) else return(rep(1,length(loc)))\n\nrloc <- function(k,min=0,max=1){\n  return(runif(k))\n}",
    "created" : 1379440877424.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "256811586",
    "id" : "A26EA678",
    "lastKnownWriteTime" : 1379581827,
    "path" : "~/repos/bayou/bayou_1.0/R/probability.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}