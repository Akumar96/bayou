{
    "contents" : "#' Calculate the weight matrix of a set of regimes on a phylogeny\n#' \n#' These functions calculate weight matrices from regimes specified in phytools' simmap format.\n#' \\code{simmap.W} calculates the weight matrix for a set of regimes from a phylogeny\n#' with a stored regime history. \\code{.simmap.W} calculates the same matrix, but without checks and is \n#' generally run internally. \n#' \n#' @rdname simmap.W\n#' @param tree either a tree of class \"phylo\" or a cache object produced by bayOU's internal \n#' functions. Must include list element 'maps' which is a simmap reconstruction of regime history.\n#' @param pars a list of the parameters used to calculate the weight matrix. Only pars$alpha is\n#' necessary to calculate the matrix, but others can be present.\n#' @param TotExp a parameter dependent on the total tree height and the alpha parameter that determines\n#' the influence of the root state. \n#' \n#' @details \\code{.simmap.W} is more computationally efficient within a mcmc and is used internally. The value\n#' of \\code{TotExp} is supplied to speed computation and reduce redundancy, and cache objects must be supplied as\n#' the phylogeny, and the parameter \\code{ntheta} must be present in the list \\code{pars}.\nsimmap.W <- function(tree,pars){\n  if(class(tree)==\"phylo\"){\n    X <- rep(NA,length(tree$tip.label))\n    names(X) <- tree$tip.label\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  if(is.null(pars$ntheta)){\n    pars$ntheta <- length(unique(names(unlist(cache$maps))))\n  }\n  nbranch <- length(cache$edge.length)\n  maps <- cache$maps\n  shifts <- unlist(lapply(maps,length),F,F)-1\n  irow <- rep(1:nbranch,shifts+1)\n  csbase <- cache$nH[irow]\n  csmaps <- csbase+unlist(lapply(maps,cumsum),FALSE,TRUE)\n  multips <- which(irow[2:length(irow)]==irow[1:(length(irow)-1)])\n  csbase[multips+1] <- csmaps[multips]\n  oW <- pars$alpha*(csbase-cache$height)\n  nW <- (csmaps-csbase)*pars$alpha\n  if(any(nW>500)){\n    tmp <- ifelse(nW>500, exp(nW+oW), exp(oW)*(exp(nW)-1))\n  } else {\n    tmp <- exp(oW)*(exp(nW)-1)\n  }\n  bW <- matrix(0,nrow=nbranch,ncol=pars$ntheta)\n  index <- irow + (as.integer(names(tmp))-1)*nbranch\n  if(any(shifts>1)){\n    tmp <- tapply(tmp,index,sum)\n    bW[as.numeric(names(tmp))] <- tmp\n  } else {bW[index] <- tmp}\n  W=cache$branchtrace%*%bW\n  W[,1] <- W[,1]+exp(-cache$height*pars$alpha)\n  return(W)\n}\n\n\n#' @rdname simmap.W\n.simmap.W <- function(cache,pars){\n  nbranch <- length(cache$edge.length)\n  maps <- cache$maps\n  #Dangerous...may not have listed the shift (if shift occurs at node)\n  shifts <- unlist(lapply(maps,length),F,F)-1\n  #Index vector indicating which branch a given segment exists on\n  irow <- rep(1:nbranch,shifts+1)\n  #Height of the beginning of each branch\n  csbase <- cache$nH[irow]\n  #Height of the end of each segment\n  csmaps <- csbase+unlist(lapply(maps,cumsum),FALSE,TRUE)\n  #Determine which branches contain more than one segment\n  multips <- which(irow[2:length(irow)]==irow[1:(length(irow)-1)])\n  #Set segments with more than one shift per branch to start at end of last shift\n  csbase[multips+1] <- csmaps[multips]\n  #Exponential term 1\n  oW <- pars$alpha*(csbase-cache$height)\n  #Exponential term 2\n  nW <- (csmaps-csbase)*pars$alpha\n  #If value of expnential term is too large (resulting in overflow), then use approximation\n  if(any(nW>500)){\n    tmp <- ifelse(nW>500, exp(nW+oW), exp(oW)*(exp(nW)-1))\n  } else {\n    tmp <- exp(oW)*(exp(nW)-1)\n  }\n  #Set up branch weight matrix\n  bW <- matrix(0,nrow=nbranch,ncol=pars$ntheta)\n  #Set up index over matrix, so that values go to right row index and column, based on the name of the segment in maps\n  index <- irow + (as.integer(names(tmp))-1)*nbranch\n  if(any(shifts>1)){\n    tmp <- tapply(tmp,index,sum)\n    bW[as.numeric(names(tmp))] <- tmp\n  } else {bW[index] <- tmp}\n  W=cache$branchtrace%*%bW\n  W[,1] <- W[,1]+exp(-cache$height*pars$alpha)\n  return(W)\n}\n\n#' Calculate the weight matrix of a set of regimes on a phylogeny using an edge map.\n#' \n#' @rdname edgemap.W\nedgemap.W <- function(tree, pars,emap,alpha=NULL){\n  if(class(tree)==\"phylo\"){\n    ntips <- length(tree$tip.label)\n    X <- rep(1,ntips)\n    names(X) <- tree$tip.label\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  if(is.null(pars)){\n    pars$alpha <- alpha\n    pars$ntheta <- sum(emap$sh)+1\n  }\n  TotExp <- exp(-cache$height*pars$alpha)\n  if(pars$ntheta>1){\n    tmp <- exp(cbind(cache$nH,cache$nH+emap$r1,cache$nH+emap$r1+emap$r2)*pars$alpha)\n    tmp2 <- (tmp[,2:3]-tmp[,1:2])*TotExp\n    bW <- matrix(0,nrow=dim(emap)[1],ncol=pars$ntheta)\n    index <- 1:dim(emap)[1]+(emap$t2-1)*dim(emap)[1]\n    bW[index] <- tmp2[,2]\n    index <- 1:dim(emap)[1]+(emap$t1-1)*dim(emap)[1]\n    bW[index] <- tmp2[,1]                    \n    W=cache$branchtrace%*%bW#t(sapply(cache$branchtrace,function(x) .colSums(bW[x,],sum(x),pars$ntheta)))\n    W[,1] <- W[,1]+TotExp\n    W[W==Inf] <- NA\n    if(mean(cache$nH/(log(2)/pars$alpha))>600 & sum(is.na(W))>0){\n      sub <- subset(emap,!is.na(emap$tip))\n      t2.tmp <- sub$t2\n      names(t2.tmp) <- sub$tip\n      t2.tmp <- t2.tmp[cache$tip.label]\n      for(k in 1:length(t2.tmp)){\n        if(is.na(W[k,t2.tmp[k]])){\n          W[k,t2.tmp[k]] <- 1\n        }\n      }\n      W[is.na(W)] <- 0\n    }\n  } else {W <-  rep(1,cache$ntips)}\n  W\n}\n#' @rdname edgemap.W\n.edgemap.W <- function(cache, pars,emap,TotExp,alpha=NULL){\n  if(pars$ntheta>1){\n    tmp <- exp(cbind(cache$nH,cache$nH+emap$r1,cache$nH+emap$r1+emap$r2)*pars$alpha)\n    tmp2 <- (tmp[,2:3]-tmp[,1:2])*TotExp\n    bW <- matrix(0,nrow=dim(emap)[1],ncol=pars$ntheta)\n    index <- 1:dim(emap)[1]+(emap$t2-1)*dim(emap)[1]\n    bW[index] <- tmp2[,2]\n    index <- 1:dim(emap)[1]+(emap$t1-1)*dim(emap)[1]\n    bW[index] <- tmp2[,1]                    \n    W=cache$branchtrace%*%bW#t(sapply(cache$branchtrace,function(x) .colSums(bW[x,],sum(x),pars$ntheta)))\n    W[,1] <- W[,1]+TotExp\n    W[W==Inf] <- NA\n    if(mean(cache$nH/(log(2)/pars$alpha))>600 & sum(is.na(W))>0){\n      sub <- subset(emap,!is.na(emap$tip))\n      t2.tmp <- sub$t2\n      names(t2.tmp) <- sub$tip\n      t2.tmp <- t2.tmp[cache$tip.label]\n      for(k in 1:length(t2.tmp)){\n        if(is.na(W[k,t2.tmp[k]])){\n        W[k,t2.tmp[k]] <- 1\n       }\n      }\n      W[is.na(W)] <- 0\n    }\n  } else {W <-  rep(1,cache$ntips)}\n  W\n}\n\n\n.parmap.W <- function(cache, pars){\n  if(pars$k > 0){\n    nbranch <- length(cache$edge.length)\n    #create a vector called shifts that indicates the number of shifts for each branch\n    nshifts <- table(pars$sb)\n    shifts <- rep(0,nbranch)\n    shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts\n    #Create an index equal to the number of segments that identifies the branch on which each segment is found\n    irow <- rep(1:nbranch,shifts+1)\n    #For now, starting height is just the height of the node\n    csbase <- cache$nH[irow]\n    #Calculate the ending height by sorting the edge.length and the location of shifts by their branch identity and location\n    csadd <- c(tree$edge.length, pars$loc)\n    tmp.o <- c(1:nbranch, pars$sb)\n    names(csadd) <- tmp.o\n    add.o <- order(tmp.o,csadd)\n    csadd <- csadd[add.o]\n    #Ending height of the segment\n    csmaps <- csadd + csbase\n    #We need to know what the ending theta is for each segment, so we sort pars$t2 as we did for pars$loc, but +1 because t2 is the ending regime\n    t2index <- add.o[which(add.o > nbranch)]\n    t2b <- c(rep(1,length(csmaps)))\n    t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]\n    #Now we need to cascade these regime down the tree. We won't need to cascade sandwiches, as they are trapped on the branch they occur. So we find them below:\n    loc.o <- order(pars$loc,decreasing=TRUE)\n    sandwiches <- tmp.o[duplicated(pars$sb[loc.o])]\n    # And remove them:\n    if(length(sandwiches)>0){\n      sb.down <- pars$sb[-sandwiches]\n      t2.down <- pars$t2[-sandwiches]\n    } else {sb.down <- pars$sb; t2.down <- pars$t2}\n    #Now we order the sb's and t2's to prepare for a postorder tree traversal\n    sb.o <- order(sb.down)\n    sb.down <- sb.down[sb.o]\n    t2.down <- t2.down[sb.o]\n    sb.desc <- cache$bdesc[sb.down]\n    #Loop traveling down the tree, saving all descendents that are from that shift into the vector censored. These branches cannot be modified by shifts further down the tree.\n    censored <- NULL\n    name.o <- names(csmaps)\n    names(t2b) <- name.o\n    for(i in 1:length(sb.desc)){\n      sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]\n      censored <- c(censored, sb.desc[[i]])\n      t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]\n    }\n    names(csmaps) <- t2b\n    multips <- which(irow[2:length(irow)]==irow[1:(length(irow)-1)])\n    #Set segments with more than one shift per branch to start at end of last shift\n    csbase[multips+1] <- csmaps[multips]\n    #Exponential term 1\n    oW <- pars$alpha*(csbase-cache$height)\n    #Exponential term 2\n    nW <- (csmaps-csbase)*pars$alpha\n    #If value of expnential term is too large (resulting in overflow), then use approximation\n    if(any(nW>500)){\n      tmp <- ifelse(nW>500, exp(nW+oW), exp(oW)*(exp(nW)-1))\n    } else {\n      tmp <- exp(oW)*(exp(nW)-1)\n    }\n    #Set up branch weight matrix\n    bW <- matrix(0,nrow=nbranch,ncol=pars$ntheta)\n    #Set up index over matrix, so that values go to right row index and column, based on the name of the segment in maps\n    index <- irow + (as.integer(names(tmp))-1)*nbranch\n    if(any(duplicated(index))){\n      tmp <- tapply(tmp,index,sum)\n      bW[as.numeric(names(tmp))] <- tmp\n    } else {bW[index] <- tmp}\n    W=cache$branchtrace%*%bW\n    W[,1] <- W[,1]+exp(-cache$height*pars$alpha)\n  } else {\n    W <- matrix(rep(1,cache$ntips),ncol=1)\n  }\n  return(W)\n}\n\n\nparmap.W <- function(tree, pars){\n  if(class(tree)==\"phylo\"){\n    X <- rep(NA,length(tree$tip.label))\n    names(X) <- tree$tip.label\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  if(is.null(pars$ntheta)){\n    pars$ntheta <- length(pars$theta)\n  }\n  if(pars$k > 0){\n    nbranch <- length(cache$edge.length)\n    #create a vector called shifts that indicates the number of shifts for each branch\n    nshifts <- table(pars$sb)\n    shifts <- rep(0,nbranch)\n    shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts\n    #Create an index equal to the number of segments that identifies the branch on which each segment is found\n    irow <- rep(1:nbranch,shifts+1)\n    #For now, starting height is just the height of the node\n    csbase <- cache$nH[irow]\n    #Calculate the ending height by sorting the edge.length and the location of shifts by their branch identity and location\n    csadd <- c(tree$edge.length, pars$loc)\n    tmp.o <- c(1:nbranch, pars$sb)\n    names(csadd) <- tmp.o\n    add.o <- order(tmp.o,csadd)\n    csadd <- csadd[add.o]\n    #Ending height of the segment\n    csmaps <- csadd + csbase\n    #We need to know what the ending theta is for each segment, so we sort pars$t2 as we did for pars$loc, but +1 because t2 is the ending regime\n    t2index <- add.o[which(add.o > nbranch)]\n    t2b <- c(rep(1,length(csmaps)))\n    t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]\n    #Now we need to cascade these regime down the tree. We won't need to cascade sandwiches, as they are trapped on the branch they occur. So we find them below:\n    loc.o <- order(pars$loc,decreasing=TRUE)\n    sandwiches <- tmp.o[duplicated(pars$sb[loc.o])]\n    # And remove them:\n    if(length(sandwiches)>0){\n      sb.down <- pars$sb[-sandwiches]\n      t2.down <- pars$t2[-sandwiches]\n    } else {sb.down <- pars$sb; t2.down <- pars$t2}\n    #Now we order the sb's and t2's to prepare for a postorder tree traversal\n    sb.o <- order(sb.down)\n    sb.down <- sb.down[sb.o]\n    t2.down <- t2.down[sb.o]\n    sb.desc <- cache$bdesc[sb.down]\n    #Loop traveling down the tree, saving all descendents that are from that shift into the vector censored. These branches cannot be modified by shifts further down the tree.\n    censored <- NULL\n    name.o <- names(csmaps)\n    names(t2b) <- name.o\n    for(i in 1:length(sb.desc)){\n      sb.desc[[i]] <- sb.desc[[i]][!(sb.desc[[i]] %in% censored)]\n      censored <- c(censored, sb.desc[[i]])\n      t2b[name.o[name.o %in% sb.desc[[i]]]] <- t2.down[i]\n    }\n    names(csmaps) <- t2b\n    multips <- which(irow[2:length(irow)]==irow[1:(length(irow)-1)])\n    #Set segments with more than one shift per branch to start at end of last shift\n    csbase[multips+1] <- csmaps[multips]\n    #Exponential term 1\n    oW <- pars$alpha*(csbase-cache$height)\n    #Exponential term 2\n    nW <- (csmaps-csbase)*pars$alpha\n    #If value of expnential term is too large (resulting in overflow), then use approximation\n    if(any(nW>500)){\n      tmp <- ifelse(nW>500, exp(nW+oW), exp(oW)*(exp(nW)-1))\n    } else {\n      tmp <- exp(oW)*(exp(nW)-1)\n    }\n    #Set up branch weight matrix\n    bW <- matrix(0,nrow=nbranch,ncol=pars$ntheta)\n    #Set up index over matrix, so that values go to right row index and column, based on the name of the segment in maps\n    index <- irow + (as.integer(names(tmp))-1)*nbranch\n    if(any(duplicated(index))){\n      tmp <- tapply(tmp,index,sum)\n      bW[as.numeric(names(tmp))] <- tmp\n    } else {bW[index] <- tmp}\n    W=cache$branchtrace%*%bW\n    W[,1] <- W[,1]+exp(-cache$height*pars$alpha)\n  } else {\n    W <- matrix(rep(1,cache$ntips),ncol=1)\n  }\n  return(W)\n}\n\n\n\n",
    "created" : 1379445255826.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1669264954",
    "id" : "B08E3C6A",
    "lastKnownWriteTime" : 1380046201,
    "path" : "~/repos/bayou/bayou_1.0/R/bayou-weight_matrix.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}