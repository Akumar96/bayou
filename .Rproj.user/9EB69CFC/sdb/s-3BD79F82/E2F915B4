{
    "contents" : "oumcmc.loader <- function(dir=NULL,outname=\"bayou\",model=\"OU\"){\n  #mapsr2 <- read.table(file=\"mapsr2.dta\",header=FALSE)\n  #mapsb <- read.table(file=\"mapsb.dta\",header=FALSE)\n  #mapst2 <- read.table(file=\"mapst2.dta\",header=FALSE)\n  mapsr2 <- scan(file=paste(dir,outname,\".mapsr2\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  mapsb <- scan(file=paste(dir,outname,\".mapsb\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  mapst2 <- scan(file=paste(dir,outname,\".mapst2\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  pars.out <- scan(file=paste(dir,outname,\".pars\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  pars.out <- lapply(strsplit(pars.out,\"[[:space:]]+\"),as.numeric)\n  mapsr2 <- lapply(strsplit(mapsr2,\"[[:space:]]+\"),as.numeric)\n  mapsb <- lapply(strsplit(mapsb,\"[[:space:]]+\"),as.numeric)\n  mapst2 <- lapply(strsplit(mapst2,\"[[:space:]]+\"),as.numeric)\n  chain <- list()\n  if(model==\"OU\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$alpha <- sapply(pars.out,function(x) x[4])\n    chain$sig2 <- sapply(pars.out,function(x) x[5])\n    chain$nb <- sapply(pars.out,function(x) x[6])\n    chain$ntheta <- sapply(pars.out,function(x) x[7])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:7)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  if(model==\"QG\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$h2 <- sapply(pars.out,function(x) x[4])\n    chain$P <- sapply(pars.out,function(x) x[5])\n    chain$w2 <- sapply(pars.out,function(x) x[6])\n    chain$Ne <- sapply(pars.out,function(x) x[7])\n    chain$nb <- sapply(pars.out,function(x) x[8])\n    chain$ntheta <- sapply(pars.out,function(x) x[9])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:9)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  if(model==\"OUrepar\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$halflife <- sapply(pars.out,function(x) x[4])\n    chain$Vy <- sapply(pars.out,function(x) x[5])\n    chain$nb <- sapply(pars.out,function(x) x[6])\n    chain$ntheta <- sapply(pars.out,function(x) x[7])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:7)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  return(chain)\n}\n\n\ngelman.R <- function(parameter,chain1,chain2,freq=20,start=1,plot=TRUE){\n  R <- NULL\n  R.UCI <- NULL\n  int <- seq(start,length(chain1[[parameter]]),freq)\n  for(i in 1:length(int)){\n    chain.list <- mcmc.list(mcmc(chain1[[parameter]][1:int[i]]),mcmc(chain2[[parameter]][1:int[i]]))\n    GD <- gelman.diag(chain.list)\n    R[i] <- GD$psrf[1]\n    R.UCI[i] <- GD$psrf[2]\n  }\n  if(plot==TRUE){\n    plot(chain1$gen[int],R,ylim=c(0.9,1.8),main=paste(\"Gelman's R:\",parameter),xlab=\"Generation\",ylab=\"R\",lwd=2)\n    lines(chain1$gen[int],R,lwd=2)\n    lines(chain1$gen[int],R.UCI,lty=2)\n  }\n  return(data.frame(\"R\"=R,\"UCI.95\"=R.UCI))\n}\nposterior.Q <- function(parameter,chain1,chain2,pars=simpar$pars,burnin=0.3){\n  postburn <- round(burnin*length(chain1$gen),0):length(chain1$gen)\n  chain <- mcmc.list(mcmc(chain1[[parameter]][postburn]),mcmc(chain2[[parameter]][postburn]))\n  posterior.q <- summary(chain,quantiles=seq(0,1,0.005))$quantiles\n  q <- which(names(sort(c(pars[[parameter]],posterior.q)))==\"\")\n  Q <- ((q-1)/2-0.25)/100#((q-1)+(simpar$pars$alpha-posterior.q[q-1])/(posterior.q[q+1]-posterior.q[q-1]))/100\n  Q\n}\n\nLposterior <- function(chain.list,phy,simpar=NULL,burnin=0.3,mag=TRUE){\n  ntips <- length(phy$tip.label)\n  shifts=list()\n  branch.shifts=list()\n  optima <- list()\n  postburn <- round(burnin*length(chain.list[[1]]$gen),0):length(chain.list[[1]]$gen)\n  for(i in 1:length(chain.list)){\n    shifts[[i]] <- t(sapply(chain.list[[i]]$branch.shift[postburn],function(x) as.numeric(1:nrow(phy$edge) %in% x)))\n    optima[[i]] <- sapply(1:length(chain.list[[i]]$optima),function(x) chain.list[[i]]$optima[[x]][chain.list[[i]]$t2[[x]]])\n    branch.shifts[[i]] <- chain.list[[i]]$branch.shift\n  }\n  optima.shifts <- tapply(unlist(optima),unlist(branch.shifts),mean)\n  N.optima.shifts <- tapply(unlist(branch.shifts),unlist(branch.shifts),length)\n  root.optima <- sapply(chain.list,function(x) sapply(x$optima,function(y) y[1]))\n  OS <- rep(mean(root.optima),length(phy$edge[,1]))\n  OS[as.numeric(names(optima.shifts))] <- optima.shifts\n  shifts.tot <- sapply(shifts,function(x) apply(x,2,sum))\n  shifts.prop <- shifts.tot/length(postburn)\n  if (!is.null(simpar)){\n    bshift <- subset(simpar$edge.map,simpar$edge.map$sh==1)\n    shift.mag <- simpar$pars$optima[bshift$t2]-simpar$pars$optima[bshift$t1]\n    all.branches <- rep(0,nrow(simpar$edge.map))\n    all.branches[as.numeric(rownames(bshift))] <- shift.mag\n    shift.age <- (nodeHeights(simpar$tree)[,1]+simpar$edge.map$r1)\n    prior.prob <- sum(sapply(1:(ntips/2),function(x) kFUN(x,log=FALSE)*sum(1/(length(all.branches):(length(all.branches)-(x-1))))))\n    Lpost <- data.frame(shifts.prop,\"prior\"=prior.prob,\"pp2prior\"=apply(shifts.prop,1,mean)/prior.prob,\"sh\"=simpar$edge.map$sh,\"shift.mag\"=all.branches,\"shift.age\"=shift.age)\n  } else {\n    all.branches <- rep(0,nrow(phy$edge))\n    prior.prob <- sum(sapply(1:(ntips/2),function(x) kFUN(x,log=FALSE)*sum(1/(length(all.branches):(length(all.branches)-(x-1))))))\n    Lpost <- data.frame(shifts.prop,\"prior\"=prior.prob,\"pp2prior\"=apply(shifts.prop,1,mean)/prior.prob,mag=OS)\n  }\n  return(Lpost)\n}\n\n\ndiscard.burnin <- function(chain,burnin.prop=0.3){\n  lapply(chain,function(x) x[(burnin.prop*length(x)):length(x)])\n}\n\nbuild.control <- function(pars,emap,default.weights=\"OU\",move.weights=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"nb\"=10)){\n  if(!is.null(default.weights)){\n    if(default.weights==\"OU\"){\n      move.weights=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"nb\"=10)\n    }\n    if(default.weights==\"QG\"){\n      move.weights=list(\"h2\"=5,\"P\"=2,\"w2\"=5,\"Ne\"=5,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"nb\"=20)\n    }\n    if(default.weights==\"OUrepar\"){\n      move.weights=list(\"halflife\"=5,\"Vy\"=3,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"nb\"=20)\n    }\n  }\n  ct <- as.list(rep(NA,length(pars)+1))\n  names(ct) <- c(names(pars),'pos')\n  names(ct)[names(ct)==\"ntheta\"] <- \"slide\"\n  total.weight <- sum(unlist(move.weights))\n  move.weights <- unlist(move.weights[names(ct)])\n  ct$nb <- unname(move.weights['nb']/total.weight)\n  R <-1-ct$nb\n  if (sum(emap$sh)== 0){\n    ct$pos <- 0\n    ct$slide <- 0\n    n.na <- sapply(ct,is.na)\n    ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n  } else {\n    if (sum(1-emap$sh)==0){\n      ct$slide <- 0\n      n.na <- sapply(ct,is.na)\n      ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n    } else {\n      n.na <- sapply(ct,is.na)\n      ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n    }\n  }\n  return(ct)\n}\n\ntune.D <- function(D,accept,accept.type){\n  tuning.samp <- (length(accept)/2):length(accept)\n  acc <- tapply(accept[tuning.samp],accept.type[tuning.samp],mean)\n  acc.length <- tapply(accept[tuning.samp],accept.type[tuning.samp],length)\n  acc.tune <- acc/0.25\n  acc.tune[acc.tune<0.5] <- 0.5\n  acc.tune[acc.tune>2] <- 2\n  D$ak <- acc.tune['alpha']*D$ak\n  D$sk <- acc.tune['sig2']*D$sk\n  D$tk <- acc.tune['theta']*D$tk\n  D$bk <- D$tk*2\n  D <- lapply(D,function(x){ names(x) <- NULL; x})\n  return(list(\"D\"=D,\"acc.tune\"=acc.tune))\n}\n\n\nstore.QG <- function(i,pars,maps,cache,dat,ll,pr,samp,chunk,parorder){\n  if(i%%samp==0){\n    j <- (i/samp)%%chunk\n    if(j!=0 & i>0){\n      chunk.branch[[j]] <<- (1:length(maps$sh))[maps$sh==1]\n      chunk.t2[[j]] <<- maps$t2[maps$sh==1]\n      chunk.r2[[j]] <<- maps$r2[maps$sh==1]\n      parline <- unlist(pars[parorder])\n      out[[j]] <<- c(i,ll,pr,parline)\n    } else {\n      #chunk.mapst1[chunk,] <<- maps$t1\n      #chunk.mapst2[chunk,] <<- maps$t2\n      #chunk.mapsr2[chunk,] <<- maps$r2\n      chunk.branch[[chunk]] <<- (1:length(maps$sh))[maps$sh==1]\n      chunk.t2[[chunk]] <<- maps$t2[maps$sh==1]\n      chunk.r2[[chunk]] <<- maps$r2[maps$sh==1]\n      parline <- unlist(pars[parorder])\n      out[[chunk]] <<- c(i,ll,pr,parline)\n      #write.table(chunk.mapst1,file=mapst1,append=TRUE,col.names=FALSE,row.names=FALSE)\n      #write.table(chunk.mapst2,file=mapst2,append=TRUE,col.names=FALSE,row.names=FALSE)\n      #write.table(chunk.mapsr2,file=mapsr2,append=TRUE,col.names=FALSE,row.names=FALSE)\n      lapply(out,function(x) cat(c(x,\"\\n\"),file=pars.output,append=TRUE))\n      lapply(chunk.branch,function(x) cat(c(x,\"\\n\"),file=mapsb,append=TRUE))\n      lapply(chunk.t2,function(x) cat(c(x,\"\\n\"),file=mapst2,append=TRUE))\n      lapply(chunk.r2,function(x) cat(c(x,\"\\n\"),file=mapsr2,append=TRUE))\n      #chunk.mapst1 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #chunk.mapst2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #chunk.mapsr2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #out <<- list()\n      chunk.branch <<- list()\n      chunk.r2 <<- list()\n      chunk.t2 <<- list()\n      out <<- list()\n    }\n  }\n}\n\n\npull.pars <- function(i,chain,model=\"OU\"){\n  parorder <- switch(model,\"QG\"=c(\"h2\",\"P\",\"w2\",\"Ne\",\"nb\",\"ntheta\",\"optima\"), \"OU\"=c(\"alpha\",\"sig2\",\"nb\",\"ntheta\",\"optima\"),\"OUrepar\"=c(\"halflife\",\"Vy\",\"nb\",\"ntheta\",\"optima\"))\n  pars <- lapply(parorder,function(x) chain[[x]][[i]])\n  names(pars) <- parorder\n  return(pars)\n}\n\ncombine.chains <- function(chain1,chain2,burnin.prop=0){\n  nn <- names(chain1)\n  postburn <- (burnin.prop*(length(chain1$gen))+1):(length(chain1$gen))\n  chains <- lapply(nn,function(x) c(chain1[[x]][postburn],chain2[[x]][postburn]))\n  names(chains) <- nn\n  return(chains)\n}\n\n\n.updateControl <- function(ct,pars){\n  if(pars$k==0){\n    ctM <- ct\n    R <- sum(unlist(ctM[names(ctM) %in% c(\"slide\",\"pos\")],F,F))\n    ctM[names(ctM) %in% c(\"slide\",\"pos\")] <- 0\n    nR <- !(names(ctM) %in% c(\"bk\",\"dk\",\"slide\",\"pos\"))\n    ctM[nR] <-lapply(ct[nR],function(x) x+R/length(nR))\n    ct <- ctM\n  }\n  return(ct)\n}\n\n.buildControl <- function(pars, prior, default.weights=\"OU\", move.weights=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"k\"=10),maxK=500){\n  if(!is.null(default.weights)){\n    move.weights <- switch(default.weights,\"OU\"=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"k\"=10),\"QG\"=list(\"h2\"=5,\"P\"=2,\"w2\"=5,\"Ne\"=5,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"k\"=20),\"OUrepar\"=list(\"halflife\"=5,\"Vy\"=3,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"k\"=20))\n    #\"OUcpp\"=list(\"alpha\"=3,\"sig2\"=3,\"sig2jump\"=3,\"theta\"=3,\"slide\"=5,\"k\"=10),\"QGcpp\"=list(\"h2\"=1,\"P\"=1,\"w2\"=2,\"Ne\"=2,\"sig2jump\"=3,\"theta\"=3,\"slide\"=5,\"k\"=10),\"OUreparcpp\"=list(\"halflife\"=3,\"Vy\"=3,\"sig2jump\"=3,\"theta\"=3,\"slide\"=5,\"k\"=10)\n  } else {move.weights <- move.weights}\n  ct <- unlist(move.weights)\n  total.weight <- sum(ct)\n  ct <- ct/sum(ct)\n  ct <- as.list(ct)\n  bmax <- attributes(prior)$parameters$dsb$bmax\n  nbranch <- 2*attributes(prior)$parameters$dsb$ntips-2\n  prob <- attributes(prior)$parameters$dsb$prob\n  if(length(prob)==1){\n    prob <- rep(prob, nbranch)\n    prob[bmax==0] <- 0\n  }\n  type <- max(bmax)\n  if(type == Inf){\n    bdFx <- attributes(prior)$functions$dk\n    bdk <- sqrt(cumsum(c(0,bdFx(0:maxK,log=FALSE))))*0.9\n  }\n  if(type==1){\n    maxK <- nbranch-sum(bmax==0)\n    bdk <- (maxK - 0:maxK)/maxK\n  }\n  ct$dk <- bdk\n  ct$bk <- (1-bdk)\n  \n  ct$sb <- list(bmax=bmax, prob=prob)\n  return(ct)\n}\n\nbdFx <- function(ct,max=100,pars,...){\n  dk <- cumsum(c(0,dpois(0:max,pars$lambda*T)))\n  bk <- 0.9-dk+0.1\n  return(list(bk=bk,dk=dk))\n}\n\n\nstore.bayOU <- function(i,pars,ll,pr,samp,chunk,parorder){\n  if(i%%samp==0){\n    j <- (i/samp)%%chunk\n    if(j!=0 & i>0){\n      chunk.sb[[j]] <<- pars$sb\n      chunk.t2[[j]] <<- pars$t2\n      chunk.loc[[j]] <<- pars$loc\n      parline <- unlist(pars[parorder])\n      out[[j]] <<- c(i,ll,pr,parline)\n    } else {\n      #chunk.mapst1[chunk,] <<- maps$t1\n      #chunk.mapst2[chunk,] <<- maps$t2\n      #chunk.mapsr2[chunk,] <<- maps$r2\n      chunk.sb[[chunk]] <<- pars$sb\n      chunk.t2[[chunk]] <<- pars$t2\n      chunk.loc[[chunk]] <<- pars$loc\n      parline <- unlist(pars[parorder])\n      out[[chunk]] <<- c(i,ll,pr,parline)\n      #write.table(chunk.mapst1,file=mapst1,append=TRUE,col.names=FALSE,row.names=FALSE)\n      #write.table(chunk.mapst2,file=mapst2,append=TRUE,col.names=FALSE,row.names=FALSE)\n      #write.table(chunk.mapsr2,file=mapsr2,append=TRUE,col.names=FALSE,row.names=FALSE)\n      lapply(out,function(x) cat(c(x,\"\\n\"),file=pars.output,append=TRUE))\n      lapply(chunk.sb,function(x) cat(c(x,\"\\n\"),file=mapsb,append=TRUE))\n      lapply(chunk.t2,function(x) cat(c(x,\"\\n\"),file=mapst2,append=TRUE))\n      lapply(chunk.loc,function(x) cat(c(x,\"\\n\"),file=mapsloc,append=TRUE))\n      #chunk.mapst1 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #chunk.mapst2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #chunk.mapsr2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n      #out <<- list()\n      chunk.sb <<- list()\n      chunk.t2 <<- list()\n      chunk.loc <<- list()\n      out <<- list()\n    }\n  }\n}\n\n",
    "created" : 1380155624206.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4101794788",
    "id" : "E2F915B4",
    "lastKnownWriteTime" : 1380157519,
    "path" : "~/repos/bayou/bayou_1.0/R/bayou-mcmc-utilities.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}