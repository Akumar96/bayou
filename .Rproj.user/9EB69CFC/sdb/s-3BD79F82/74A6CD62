{
    "contents" : "#' bayOU internal function. \n#' \n#' \\code{.repars} is an internal function and not generally called by the user\n#' \n#' This is an internal function borrowed from geiger.\n.repars <- function (pars, expected) \n{\n  if (!length(pars) == length(expected)) \n    stop(paste(\"The following 'pars' are expected:\\n\\t\", \n               paste(expected, collapse = \"\\n\\t\", sep = \"\"), sep = \"\"))\n  if (all(!is.null(nm <- names(pars)))) {\n    if (!all(nm %in% expected)) \n      stop(paste(\"The following 'pars' are unexpected:\\n\\t\", \n                 paste(nm[!nm %in% expected], collapse = \"\\n\\t\", \n                       sep = \"\"), sep = \"\"))\n    if (length(unique(nm)) != length(expected)) \n      stop(paste(\"The following 'pars' are expected:\\n\\t\", \n                 paste(expected, collapse = \"\\n\\t\", sep = \"\"), \n                 sep = \"\"))\n    mm = match(expected, nm)\n    return(pars[mm])\n  }\n  else {\n    return(pars)\n  }\n}\n#' bayOU internal function. \n#' \n#' \\code{.set.defaults} is an internal function and not generally called by the user\n#' \n#' This is an internal function borrowed from diversitree.\n.set.defaults <- function (f, ..., defaults = NULL) {\n  dots <- match.call(expand.dots = FALSE)[[\"...\"]]  \n  if (missing(defaults)) \n    defaults <- dots  \n  else if (is.list(defaults)) \n    defaults <- c(dots, defaults)\n  else stop(\"'defaults' must be a list\")\n  if (is.null(defaults)) \n    return(f)\n  if (!all(names(defaults) %in% names(formals(f)))) \n    stop(\"Unknown defaults\")\n  att <- attributes(f)\n  formals(f)[names(defaults)] <- defaults\n  attributes(f) <- att\n  f\n}\n\n#' bayOU internal function. \n#' \n#' \\code{.prepare.ou.univariate} is an internal function and not generally called by the user\n#' \n#' This is an internal function modified from geiger's function .prepare.bm.univariate for use with OU models.\n.prepare.ou.univariate <- function(tree,X){\n  ntips <- length(tree$tip.label)\n  rownames(tree$edge) <- 1:(length(tree$edge[,1]))\n  cache <- .prepare.bm.univariate(tree,X)\n  ind <- as.numeric(rownames(cache$edge))\n  cache$nH <- nodeHeights(tree)[ind,1]\n  cache$maps <- tree$maps[ind]\n  cache$mapped.edge <- tree$mapped.edge[ind,]\n  cache$height <- max(nodeHeights(tree))\n  cache$ntips <- length(X)\n  cache$ind <- ind\n  cache$ordering <- \"postorder\"\n  cache$ht <- geiger:::.heights.cache(cache)\n  plook <- function(x){mapply(paste,x[2:length(x)],x[1:(length(x)-1)],sep=\",\")}\n  tB <- cache$desc$anc[1:ntips]\n  tB <- mapply(c,1:ntips,tB)\n  lookup <- lapply(tB,plook)\n  edge.names <- mapply(paste,cache$edge[,1],cache$edge[,2],sep=\",\")\n  cache$branchtrace <- t(sapply(lookup,function(x) as.numeric(edge.names %in% x)))\n  cache$bdesc <- lapply(edge.names,function(branch) which(edge.names %in% unique(unlist(sapply(lookup,function(look) if(branch %in% look) look[1:which(branch==look)])))))\n  cache$bdesc <- lapply(cache$bdesc,function(x) x[-length(x)])\n  cache$lookup <- lookup\n  rownames(cache$edge)=NULL\n  return(cache)\n}\n\n\n#' bayOU internal function. \n#' \n#' \\code{.prepare.bm.univariate} is an internal function and not generally called by the user\n#' \n#' This is an internal function modified from geiger's function .prepare.bm.univariate for use with OU models.\n.prepare.bm.univariate <- geiger:::.prepare.bm.univariate\n\n#' bayOU internal function. \n#' \n#' \\code{.sample} is an internal function and not generally called by the user\n#' \n#' This is an internal function modified from the base function \\code{sample()} \\\\\n#' that provides consistent results with variable sample size.\n.sample <- function (x, size, replace = FALSE, prob = NULL) {\n  if (missing(size)) \n    size <- length(x)\n  x[.Internal(sample(length(x), size, replace, prob))]\n}\n\n#' bayOU internal function. \n#' \n#' \\code{.heights.cache} is an internal function and not generally called by the user\n#' \n#' This is an internal function taken from geiger.\n.heights.cache <- function (cache) {\n  if (is.null(cache$ordering) || cache$ordering != \"postorder\") {\n    stop(\"'cache' should be postordered\")\n  }\n  n <- cache$n.tip\n  n.node <- cache$n.node\n  xx <- numeric(n + n.node)\n  for (i in nrow(cache$edge):1) xx[cache$edge[i, 2]] <- xx[cache$edge[i, \n                                                     1]] + cache$edge.length[i]\n  root = ifelse(is.null(cache$root.edge), 0, cache$root.edge)\n  depth = max(xx)\n  tt = depth - xx\n  idx = 1:length(tt)\n  dd = cache$edge.length[idx]\n  mm = match(1:length(tt), c(cache$edge[, 2], n + 1))\n  dd = c(cache$edge.length, root)[mm]\n  ss = tt + dd\n  res = cbind(ss, tt)\n  rownames(res) = idx\n  colnames(res) = c(\"start\", \"end\")\n  res = data.frame(res)\n  res\n}\n\nprint.priorFn <- function(x, ...){\n  cat(\"prior function for bayOU\\n\")\n  cat(paste(\"expecting \", attributes(x)$model, \" model\\n\", sep=\"\"))\n  cat(\"'pars' should be a list with named parameter values: list(\", paste(gsub('^[a-zA-Z]',\"\",names(attributes(x)$param)),collapse=\", \"),\")\\n\",sep=\"\")\n  cat(\"prior distribution functions for used:\\n\")\n  print(unlist(attributes(prior)$dist))\n  cat(\"\\n\")\n  cat(\"definition:\\n\")\n  attributes(prior) <- NULL\n  print(prior)\n}\n\n\n.filldown.emap <- function(emap){\n  shifts <- emap$sh\n  K <- sum(shifts)\n  nopt <- rep(1,length(shifts)+1)\n  opt <- 1\n  for(i in length(shifts):1){\n    if(shifts[i]==1){\n      opt <- opt+1\n      nopt[emap$e2[i]] <- opt\n    } else {\n      nopt[emap$e2[i]] <- nopt[emap$e1[i]]\n    }\n  }\n  edge.map <- data.frame(tree$edge,nopt[tree$edge[,1]],nopt[tree$edge[,2]],shifts,tree$tip.label[tree$edge[,2]],emap$r1,emap$r2,tree$edge.length)\n  names(edge.map) <- c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(edge.map)\n}\n\nouMatrix <- function(vcvMatrix, alpha)\n{  vcvDiag<-diag(vcvMatrix)\n   diagi<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag))\n   diagj<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag), byrow=T)\n   Tij = diagi + diagj - (2 * vcvMatrix)\n   vcvRescaled = (1 / (2 * alpha)) * exp(-alpha * Tij) * (1 - exp(-2 * alpha * vcvMatrix))\n   return(vcvRescaled)\n}",
    "created" : 1379457105473.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2541504846",
    "id" : "74A6CD62",
    "lastKnownWriteTime" : 1380013550,
    "path" : "~/repos/bayou/bayou_1.0/R/bayou-utilities.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}