{
    "contents" : "emap2simmap <- function(emap,tree){\n  foo <- function(x){\n    tmp <- unlist(emap[x,c('r1','r2')])\n    names(tmp) <- c(emap$t1[x],emap$t2[x])\n    tmp[tmp>0]\n  }\n  nb <- sum(emap$sh)\n  if(nb>0){\n    col <- c(\"#000000\",rainbow(nb))\n  } else {col <- 1}\n  names(col) <- 1:(nb+1)\n  tree$maps <- lapply(1:dim(emap)[1],foo)\n  tree$col <- col\n  tree\n}\n\npars2simmap <- function(pars,tree,theta=NULL,root.theta=0){\n  sb <- pars$sb\n  loc <- pars$loc\n  t2 <- pars$t2\n  Th <- theta\n  nbranch <- length(tree$edge.length)\n  maps <- lapply(tree$edge.length,function(x){y <- x; names(y) <- 1; y})\n  dup <- which(duplicated(sb))\n  if(length(dup)>0){\n    maps[sb[-dup]] <- lapply(1:length(sb[-dup]),addshift2map,maps=maps,sb=sb[-dup],loc=loc[-dup],t2=t2[-dup])\n  } else {\n    maps[sb] <- lapply(1:length(sb),addshift2map,maps=maps,sb=sb,loc=loc,t2=t2)\n  }\n  for(i in dup){\n    maps[[sb[i]]] <-addshift2map(i,maps=maps,sb=sb,loc=loc,t2=t2)\n  }\n  nopt <- rep(1,nbranch)\n  for(i in nbranch:1){\n    if(i %in% sb){\n      opt <- as.integer(names(maps[[i]])[length(maps[[i]])])\n      nopt[tree$edge[i,2]] <- opt\n      names(maps[[i]])[1] <- nopt[tree$edge[i,1]]\n    } else {\n      names(maps[[i]])[1] <- nopt[tree$edge[i,1]] \n      nopt[tree$edge[i,2]] <- nopt[tree$edge[i,1]]\n    }\n  }\n  shiftdown <- nopt[tree$edge[,1]]\n  new.maps <- lapply(1:nbranch,function(x){names(maps[[x]])[1] <- shiftdown[x]; maps[[x]]})\n  new.maps <- maps\n  for(j in 1:nbranch){\n    names(new.maps[[j]])[1] <-shiftdown[j]\n  }\n  anc.theta <- unlist(lapply(new.maps[sb],function(x) as.integer(names(x)[length(x)-1])),F,F)\n  o <- rev(order(sb,loc*-1))\n  shifted.maps <- new.maps[sb[o]]\n  t1 <- rep(NA,length(t2))\n  for(i in 1:length(t2)){\n    nm <- as.integer(names(maps[[sb[o][i]]]))\n    t1[nm[2:length(nm)]-1] <- nm[1:(length(nm)-1)]\n    Th[t2[o[i]]] <- Th[t1[o[i]]]\n  }\n  new.tree <- tree\n  new.tree$maps <- new.maps\n  new.pars <- pars\n  col <- c(1,rainbow(pars$k))\n  names(col) <- 1:(pars$k+1)\n  return(list(tree=new.tree,pars=new.pars,col=col))\n}\n\n.pars2map <- function(pars, cache){\n  nbranch <- length(cache$edge.length)\n  nshifts <- table(pars$sb)\n  shifts <- rep(0,nbranch)\n  shifts[as.numeric(attributes(nshifts)$dimnames[[1]])]<- nshifts\n  irow <- rep(1:nbranch,shifts+1)\n  segs <- c(tree$edge.length, pars$loc)\n  tmp.o <- c(1:nbranch, pars$sb)\n  names(segs) <- tmp.o\n  add.o <- order(tmp.o,segs)\n  segs <- segs[add.o]\n  ind <- names(segs)\n  t2index <- add.o[which(add.o > nbranch)]\n  t2b <- c(rep(1,length(segs)))\n  t2b[match(t2index,add.o)+1] <- pars$t2[t2index-nbranch]\n  loc.o <- order(pars$loc,decreasing=TRUE)\n  sandwiches <- loc.o[duplicated(pars$sb[loc.o])]\n  if(length(sandwiches)>0){\n    sb.down <- pars$sb[-sandwiches]\n    t2.down <- pars$t2[-sandwiches]\n  } else {sb.down <- pars$sb; t2.down <- pars$t2}\n  sb.o <- order(sb.down)\n  sb.down <- sb.down[sb.o]\n  t2.down <- t2.down[sb.o]\n  sb.desc <- cache$bdesc[sb.down]\n  desc.length <- unlist(lapply(sb.desc, length),F,F)\n  sb.desc <- sb.desc[desc.length>0]\n  names(t2b) <- names(segs)\n  sb.desc2 <- unlist(sb.desc,F,F)\n  sb.dup <- duplicated(sb.desc2)\n  sb.desc3 <- sb.desc2[!sb.dup]\n  t2.names <- rep(t2.down[desc.length>0], unlist(lapply(sb.desc,length),F,F))\n  t2.names <- t2.names[!sb.dup]\n  t2b[as.character(unlist(sb.desc3,F,F))] <- t2.names\n  base <- duplicated(names(segs))*c(0,segs[1:(length(segs)-1)])\n  segs <- segs-base\n  #maps <- lapply(1:nbranch, function(x) segs[ind==x])\n  #maps <- lapply(maps, function(x) if(length(x) >1) {c(x[1],diff(x[1:length(x)]))} else x)\n  return(list(segs=segs,theta=t2b))\n}\n\nQG.alpha <- function(pars){\n  pars$h2*pars$P/(pars$P+pars$w2*pars$P)\n}\nQG.sig2 <- function(pars){\n  (pars$h2*pars$P)/pars$Ne\n}\n\nOU.repar <- function(pars){\n  alpha <- log(2)/pars$halflife\n  sig2 <- (2*log(2)/(pars$halflife))*pars$Vy\n  return(list(alpha=alpha,sig2=sig2))\n}\n\n\n#' Return an edge map for a given generation from a bayOU mcmc list\npull.emap <- function(i,chain,cache){\n  sb <- chain$branch.shift[[i]]\n  t2 <- chain$t2[[i]]\n  sl <- chain$location[[i]]\n  phy <- cache$phy\n  shifts <- rep(0,length(cache$edge.length))\n  shifts[sb] <- 1\n  nopt <- rep(1,length(shifts)+1)\n  opt <- 1\n  j <- length(t2)\n  phy$maps <- lapply(phy$edge.length,function(x){names(x) <- 1; x})\n  if(length(sb)>0){\n    phy$maps[sb] <- lapply(1:length(sb),function(x){y <- c(sl[x],phy$maps[[sb[x]]]-sl[x]);names(y)[2] <- t2[x] ;y})\n    for(i in length(shifts):1){\n      if(shifts[i]==1){\n        opt <- t2[j]\n        nopt[phy$edge[i,2]] <- opt\n        j <- j-1\n      } else {\n        nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n      }\n    }\n  }\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[1] <- nopt[phy$edge[x,1]];phy$maps[[x]] })\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[length(phy$maps[[x]])] <- nopt[phy$edge[x,2]];phy$maps[[x]] })\n  S <- phy$edge.length\n  S[sb] <- phy$edge.length[sb]-sl\n  S2 <- rep(0,length(shifts))\n  S2[sb] <- sl\n  edge.map <- data.frame(phy$edge,nopt[phy$edge[,1]],nopt[phy$edge[,2]],shifts,phy$tip.label[phy$edge[,2]],S,S2,phy$edge.length)\n  colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(list(phy=phy,emap=edge.map))\n}\n\n#' Generate an edge map from a vector of branches, shift locations and optima assignments\nread.emap <- function(sb,sl,t2,phy){\n  shifts <- rep(0,length(phy$edge.length))\n  shifts[sb] <- 1\n  nopt <- rep(1,length(shifts))\n  opt <- 1\n  j <- 1\n  phy$maps <- lapply(phy$edge.length,function(x){names(x) <- 1; x})\n  if(length(sb)>0){\n    phy$maps[sb] <- lapply(1:length(sb),function(x){y <- c(sl[x],phy$maps[[sb[x]]]-sl[x]);names(y)[2] <- x+1 ;y})\n    for(i in length(shifts):1){\n      if(shifts[i]==1){\n        opt <- t2[j]\n        nopt[phy$edge[i,2]] <- opt\n        j <- j+1\n      } else {\n        nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n      }\n    }\n  }\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[1] <- nopt[phy$edge[x,1]];phy$maps[[x]] })\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[length(phy$maps[[x]])] <- nopt[phy$edge[x,2]];phy$maps[[x]] })\n  S <- phy$edge.length\n  S[sb] <- sl\n  S2 <- rep(0,length(shifts))\n  S2[sb] <- phy$edge.length[sb]-sl\n  edge.map <- data.frame(phy$edge,nopt[phy$edge[,1]],nopt[phy$edge[,2]],shifts,phy$tip.label[phy$edge[,2]],S,S2,phy$edge.length)\n  colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(list(phy=phy,emap=edge.map))\n}\n\n",
    "created" : 1379362846152.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3515877272",
    "id" : "1B950A84",
    "lastKnownWriteTime" : 1380157508,
    "path" : "~/repos/bayou/bayou_1.0/R/conversion-utilities.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}