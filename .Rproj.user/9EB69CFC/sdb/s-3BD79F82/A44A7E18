{
    "contents" : "require(geiger)\nrequire(OUwie)\nrequire(denstrip)\nrequire(phytools)\nrequire(TreeSim)\n.proposal.multiplier=geiger:::.proposal.multiplier\n.proposal.slidingwindow=geiger:::.proposal.slidingwindow\n.prepare.bm.univariate <- geiger:::.prepare.bm.univariate\n.repars <- geiger:::.repars\nset.defaults <- diversitree:::set.defaults\n.prepare.ou.univariate <- function(tree,X){\n  ntips <- length(tree$tip.label)\n  rownames(tree$edge) <- 1:(length(tree$edge[,1]))\n  cache <- .prepare.bm.univariate(tree,X)\n  ind <- as.numeric(rownames(cache$edge))\n  cache$nH <- nodeHeights(tree)[ind,1]\n  cache$maps <- tree$maps[ind]\n  cache$mapped.edge <- tree$mapped.edge[ind,]\n  cache$height <- max(nodeHeights(tree))\n  cache$ntips <- length(X)\n  cache$ind <- ind\n  cache$ordering <- \"postorder\"\n  cache$ht <- geiger:::.heights.cache(cache)\n  plook <- function(x){mapply(paste,x[2:length(x)],x[1:(length(x)-1)],sep=\",\")}\n  tB <- cache$desc$anc[1:ntips]\n  tB <- mapply(c,1:ntips,tB)\n  lookup <- lapply(tB,plook)\n  edge.names <- mapply(paste,cache$edge[,1],cache$edge[,2],sep=\",\")\n  cache$branchtrace <- t(sapply(lookup,function(x) as.numeric(edge.names %in% x)))\n  cache$lookup <- lookup\n  rownames(cache$edge)=NULL\n  cache\n  }\n\n\nsample <- function (x, size, replace = FALSE, prob = NULL) {\n        if (missing(size)) \n            size <- length(x)\n        x[.Internal(sample(length(x), size, replace, prob))]\n      }\n\ncdpois <- function(k,lambda,kmax,log=TRUE){\n  kmax <- ceiling(kmax)\n  i <- 0:kmax\n  R <- sum(dpois(i,lambda))\n  if(k<=kmax){\n    num <- dpois(k,lambda)\n  } else {num <- 0}\n  if(log){\n    log(num/R)\n  } else {num/R }\n}\n\nrdpois <- function(k,lambda,kmax,log=TRUE){\n  kmax <- ceiling(kmax)\n  i=rep(kmax+1,k)\n  j=0\n  while(any(i>kmax)){\n    i[i>kmax] <- rpois(sum(i>kmax),lambda)\n    j <- j+1\n    if(j>100){stop (\"Lambda too high relative to kmax\")}\n  }\n  return(i)\n}\n\nedgemap.W <- function(pars,emap,cache,TotExp,alpha=NULL){\n  if(class(cache)==\"phylo\"){\n    ntips <- length(cache$tip.label)\n    X <- rep(1,ntips)\n    names(X) <- cache$tip.label\n    cache <- .prepare.ou.univariate(cache,X)\n  }\n  if(is.null(pars)){\n    pars$alpha <- alpha\n    pars$ntheta <- sum(emap$sh)+1\n  }\n  if(pars$ntheta>1){\n    tmp <- exp(cbind(cache$nH,cache$nH+emap$r1,cache$nH+emap$r1+emap$r2)*pars$alpha)\n    tmp2 <- (tmp[,2:3]-tmp[,1:2])*TotExp\n    bW <- matrix(0,nrow=dim(emap)[1],ncol=pars$ntheta)\n    index <- 1:dim(emap)[1]+(emap$t2-1)*dim(emap)[1]\n    bW[index] <- tmp2[,2]\n    index <- 1:dim(emap)[1]+(emap$t1-1)*dim(emap)[1]\n    bW[index] <- tmp2[,1]                    \n    W=cache$branchtrace%*%bW#t(sapply(cache$branchtrace,function(x) .colSums(bW[x,],sum(x),pars$ntheta)))\n    W[,1] <- W[,1]+TotExp\n    W[W==Inf] <- NA\n    if(mean(cache$nH/(log(2)/pars$alpha))>600 & sum(is.na(W))>0){\n      sub <- subset(emap,!is.na(emap$tip))\n      t2.tmp <- sub$t2\n      names(t2.tmp) <- sub$tip\n      t2.tmp <- t2.tmp[cache$tip.label]\n      for(k in 1:length(t2.tmp)){\n        if(is.na(W[k,t2.tmp[k]])){\n          W[k,t2.tmp[k]] <- 1\n        }\n      }\n      W[is.na(W)] <- 0\n    }\n  } else {W <-  rep(1,cache$ntips)}\n  W\n}\n\n.ou.cache.fast <- function (cache) \n{\n    ht = cache$ht\n    N = cache$n.tip\n    Tmax = ht$start[N + 1]\n    mm = match(1:nrow(ht), cache$edge[, 2])\n    ht$t1 = Tmax - ht$end[cache$edge[mm, 1]]\n    ht$t2 = ht$start - ht$end + ht$t1\n    z = function(alpha) {\n        if (alpha < 0) \n            stop(\"'alpha' must be positive valued\")\n        bl = (1/(2 * alpha)) * exp(-2 * alpha * (Tmax - ht$t2)) * \n            (1 - exp(-2 * alpha * ht$t2)) - (1/(2 * alpha)) * \n            exp(-2 * alpha * (Tmax - ht$t1)) * (1 - exp(-2 * \n            alpha * ht$t1))\n        cache$len = bl\n        cache\n    }\n    attr(z, \"argn\") = \"alpha\"\n    return(z)\n}\n\nfastbm.lik <- function (phy, dat, ht, SE = NA, model = c(\"BM\", \"OU\", \"EB\", \"trend\", \n    \"lambda\", \"kappa\", \"delta\", \"drift\", \"white\"), ...) \n{\n    model = match.arg(model, c(\"BM\", \"OU\", \"EB\", \"trend\", \"lambda\", \n        \"kappa\", \"delta\", \"drift\", \"white\"))\n    cache = .prepare.bm.univariate(phy, dat, SE = SE, ...)\n    cache$ht <- ht\n    cache$ordering = attributes(cache$phy)$order\n    cache$N = cache$n.tip\n    cache$n = cache$n.node\n    cache$nn = (cache$root + 1):(cache$N + cache$n)\n    cache$intorder = as.integer(cache$order[-length(cache$order)])\n    cache$tiporder = as.integer(1:cache$N)\n    cache$z = length(cache$len)\n    FUN = switch(model, BM = .null.cache(cache), OU = .ou.cache.fast(cache), \n        EB = .eb.cache(cache), trend = .trend.cache(cache), lambda = .lambda.cache(cache), \n        kappa = .kappa.cache(cache), delta = .delta.cache(cache), \n        drift = .null.cache(cache), white = .white.cache(cache))\n    N = cache$n.tip\n    n = cache$n.node\n    z = length(cache$len)\n    rootidx = as.integer(cache$root)\n    adjvar = as.integer(attributes(cache$y)$adjse)\n    given = as.integer(attributes(cache$y)$given)\n    given[rootidx] = 1\n    adjSE = any(adjvar == 1)\n    if (model == \"drift\") {\n        adjDRIFT = TRUE\n        if (is.ultrametric(cache$phy)) {\n            warning(\"likelihoods under 'drift' and 'BM' models will be indistinguishable with an ultrametric 'phy'\")\n        }\n    }\n    else {\n        adjDRIFT = FALSE\n    }\n    datc = list(intorder = as.integer(cache$order[-length(cache$order)]), \n        tiporder = as.integer(1:N), root = rootidx, y = as.numeric(cache$y[1, \n            ]), var = as.numeric(cache$y[2, ]), n = as.integer(z), \n        given = as.integer(given), descRight = as.integer(cache$children[, \n            1]), descLeft = as.integer(cache$children[, 2]), \n        drift = 0)\n    ll.bm.direct = function(q, sigsq, se, drft, datc) {\n        if (is.null(argn(FUN))) \n            new = FUN()\n        else new = FUN(q)\n        if (adjDRIFT) \n            datc$drift = drft\n        datc$len = as.numeric(new$len)\n        .xxSE = function(cache) {\n            vv = cache$y[2, ]^2\n            ff = function(x) {\n                if (any(ww <- adjvar == 1)) {\n                  vv[which(ww)] = x^2\n                  return(vv)\n                }\n                else {\n                  return(vv)\n                }\n            }\n            return(ff)\n        }\n        modSE = .xxSE(cache)\n        datc$var = as.numeric(modSE(se))\n        out = .Call(\"bm_direct\", dat = datc, pars = as.numeric(rep(sigsq, \n            z)), package = \"geiger\")\n        loglik <- sum(out$lq)\n        if (is.na(loglik)) \n            loglik = -Inf\n        return(as.numeric(loglik))\n    }\n    class(ll.bm.direct) <- c(\"bm\", \"dtlik\", \"function\")\n    if (is.null(argn(FUN))) {\n        if (adjSE) {\n            attb = c(\"sigsq\", \"SE\", \"z0\")\n            if (adjDRIFT) \n                attb = c(attb, \"drift\")\n            lik <- function(pars) {\n                pars = .repars(pars, attb)\n                if (adjDRIFT) \n                  drft = -pars[4]\n                else drft = 0\n                datc$y[rootidx] = pars[3]\n                ll = ll.bm.direct(q = NULL, sigsq = pars[1], \n                  se = pars[2], drft, datc)\n                return(ll)\n            }\n            attr(lik, \"argn\") = attb\n        }\n        else {\n            attb = c(\"sigsq\", \"z0\")\n            if (adjDRIFT) \n                attb = c(attb, \"drift\")\n            lik <- function(pars) {\n                pars = .repars(pars, attb)\n                if (adjDRIFT) \n                  drft = -pars[3]\n                else drft = 0\n                datc$y[rootidx] = pars[2]\n                ll = ll.bm.direct(q = NULL, sigsq = pars[1], \n                  se = NULL, drft, datc)\n                return(ll)\n            }\n            attr(lik, \"argn\") = attb\n        }\n    }\n    else {\n        if (adjSE) {\n            attb = c(argn(FUN), \"sigsq\", \"SE\", \"z0\")\n            if (adjDRIFT) \n                attb = c(attb, \"drift\")\n            lik <- function(pars) {\n                pars = .repars(pars, attb)\n                if (adjDRIFT) \n                  drft = -pars[5]\n                else drft = 0\n                datc$y[rootidx] = pars[4]\n                ll = ll.bm.direct(q = pars[1], sigsq = pars[2], \n                  se = pars[3], drft = drft, datc)\n                return(ll)\n            }\n            attr(lik, \"argn\") = attb\n        }\n        else {\n            attb = c(argn(FUN), \"sigsq\", \"z0\")\n            if (adjDRIFT) \n                attb = c(attb, \"drift\")\n            lik <- function(pars) {\n                pars = .repars(pars, attb)\n                if (adjDRIFT) \n                  drft = -pars[4]\n                else drft = 0\n                datc$y[rootidx] = pars[3]\n                ll = ll.bm.direct(pars[1], sigsq = pars[2], se = NULL, \n                  drft = drft, datc)\n                return(ll)\n            }\n            attr(lik, \"argn\") = attb\n        }\n    }\n    attr(lik, \"cache\") <- cache\n    class(lik) = c(\"bm\", \"function\")\n    lik\n}\n\n\n.emOU.lik <- function(pars,emap,cache,X,SE=0,model=\"OU\",fast=TRUE){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  TotExp=exp(-cache$height*pars$alpha)\n  W <- edgemap.W(pars,emap,cache,TotExp)\n  if(pars$ntheta>1){\n    E.th=W%*%pars$optima\n  } else {E.th=W*pars$optima}\n  X.c<-X-as.vector(E.th)\n  if(fast){\n    lnL.fx<-fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n                                        #lnL.fx<-bm.lik(cache$phy,X.c,SE=NA,model=\"OU\")\n    loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0))\n  } else {\n    lnL.fx <- bm.lik(cache$phy,X.c,SE=TRUE,model=\"OU\")\n    loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  }\n  list(loglik=loglik,W=W,optima=pars$optima,resid=X.c,Exp=E.th)\n}\n\nemOU.lik <- function(pars,emap,cache,X,SE=0,alpha=NULL,sig2=NULL,theta=NULL,method=\"pruning\",W=NULL,model=\"OU\"){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  if(class(cache)==\"phylo\"){\n    cache <- .prepare.ou.univariate(cache,X)\n  }\n  if(is.null(pars)){\n    pars$ntheta <- length(unique(unlist(sapply(pars$maps,function(x) names(x)))))\n    pars$alpha <- alpha\n    pars$sig2 <- sig2\n    pars$optima <- theta\n  }\n  if(is.null(W)){\n    TotExp=exp(-cache$height*pars$alpha)\n    W <- edgemap.W(pars,emap,cache,TotExp,X)\n  }\n  E.th=as.matrix(W)%*%pars$optima\n  if(method==\"pruning\"){system.time({\n    ##Convert the data into residuals from the expected values\n    X.c<-X-as.vector(E.th)\n    ##Make the pruning algorithm function for a single-optimum OU model\n    lnL<-bm.lik(cache$phy,X.c,SE=TRUE,model=c(\"OU\"))\n    ##Call the pruning algorithm function we just made\n    loglik=lnL(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  })->time}\n  if(method==\"invert\"){system.time({\n    ##Standard calculation of the likelihood by inverting the VCV matrix\n    ouMatrix <- function(vcvMatrix, alpha)\n      {  vcvDiag<-diag(vcvMatrix)\n         diagi<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag))\n         diagj<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag), byrow=T)\n         Tij = diagi + diagj - (2 * vcvMatrix)\n         vcvRescaled = (1 / (2 * alpha)) * exp(-alpha * Tij) * (1 - exp(-2 * alpha * vcvMatrix))\n         return(vcvRescaled)\n       }\n    Sigma <- ouMatrix(vcv.phylo(cache$phy),pars$alpha)*pars$sig2\n    diag(Sigma) <- diag(Sigma)+SE\n    X.c <- X-as.vector(E.th)\n    loglik <- dmnorm(as.vector(X.c),rep(0,length(X.c)),Sigma,log=TRUE)\n  })->time}\n    list(loglik=loglik,W=W,optima=pars$optima,resid=X.c,Exp=E.th,time=time)\n}\n\n\n\n##Modified function to simulate OUCH-like data with multiple optima from edge.maps\neOU.simulate <- function(pars=NULL, emap=NULL, tree=NULL,maps=NULL,anc=0,alpha=1,sig2=1,ntips=100,birth=1,regime.shifts=4,theta=c(0:4*2),prob=\"equal\",tipshifts=TRUE,plot=TRUE,phenogram=TRUE,model=\"OU\"){\n  if(!is.null(pars)){\n    regime.shifts <- pars$nb\n    alpha <- pars$alpha\n    sig2 <- pars$sig2\n    ntheta <- pars$ntheta\n    theta <- pars$optima\n  } else {\n    pars$alpha <- alpha\n    pars$sig2 <- sig2\n    pars$ntheta <- regime.shifts+1\n    pars$optima <- theta\n    pars$nb <- regime.shifts\n  }\n  if(is.null(tree)){\n    tree <- pbtree(b=birth,n=(ntips+1))\n    tree <- drop.tip(tree,paste(\"t\",ntips+1,sep=\"\"))\n    tree <- reorder(tree,\"postorder\")\n  } else {\n    ntips <- length(tree$tip.label)\n    tree <- reorder(tree,\"postorder\")\n  }\n  if(is.null(emap)){\n    if(regime.shifts>0){\n      if(tipshifts){plim <- 0} else {plim <- ntips}\n      if(prob==\"cladesize\"){\n        pp <- sapply(mapply(tips,tree$edge[tree$edge[,2]>plim,1],MoreArgs=list(\"phy\"=tree)),length)\n      }\n      if(prob==\"branchlength\"){\n        pp <- tree$edge.length[tree$edge[,2]>plim]\n      }\n      if(prob==\"equal\"){\n        pp <- rep(1,2*ntips-2-plim)\n      }\n      pp <- pp/sum(pp)\n      maps <- lapply(tree$edge.length,function(x){names(x) <- 1; x})\n      sb <- sample((1:(2*ntips-2))[tree$edge[,2]>plim],regime.shifts,replace=FALSE,prob=pp)\n      sb <- sb[rev(order(sb))]\n      sl <- runif(regime.shifts)*tree$edge.length[sb]\n      maps[sb] <- lapply(1:regime.shifts,function(x){y <- c(maps[[sb[x]]]-sl[x],sl[x]);names(y)[2] <- x+1 ;y})\n      shifts <- rep(0,2*ntips-2)+(1:(2*ntips-2) %in% sb)\n      nopt <- rep(1,length(shifts)+1)\n      opt <- 1\n      for(i in length(shifts):1){\n        if(shifts[i]==1){\n          opt <- opt+1\n          nopt[tree$edge[i,2]] <- opt\n        } else {\n          nopt[tree$edge[i,2]] <- nopt[tree$edge[i,1]]\n        }\n      }\n      maps <- lapply(1:length(shifts),function(x){ names(maps[[x]])[1] <- nopt[tree$edge[x,1]];maps[[x]] })\n      maps <- lapply(1:length(shifts),function(x){ names(maps[[x]])[length(maps[[x]])] <- nopt[tree$edge[x,2]];maps[[x]] })\n      S <- tree$edge.length\n      S[sb] <- sl\n      S2 <- rep(0,length(shifts))\n      S2[sb] <- tree$edge.length[sb]-sl\n      edge.map <- data.frame(tree$edge,nopt[tree$edge[,1]],nopt[tree$edge[,2]],shifts,tree$tip.label[tree$edge[,2]],S,S2,tree$edge.length)\n      colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n    } else {\n      maps <- lapply(tree$edge.length,function(x){names(x) <- 1; x})\n      edge.map <- data.frame(tree$edge,1,1,0,tree$tip.label[tree$edge[,2]],tree$edge.length,0,tree$edge.length)\n      colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n    }\n    tree <- emap2simmap(edge.map,tree)\n  } else {\n    edge.map <- emap\n    tree <- emap2simmap(edge.map,tree)\n  }\n # tree$mapped.edge <- matrix(data = 0, nrow=length(tree$edge.length), \n #           ncol=regime.shifts+1, dimnames = list(apply(tree$edge,1, function(x) paste(x, collapse = \",\")),state=1:(regime.shifts+1)))\n # for (j in 1:length(tree$maps)) for (k in 1:length(tree$maps[[j]])) tree$mapped.edge[j, \n #           names(tree$maps[[j]])[k]] <- tree$mapped.edge[j,names(tree$maps[[j]])[k]] + tree$maps[[j]][k]\n  if(plot==TRUE){\n    if(pars$nb>0){\n      col=c(\"#000000\",rainbow(pars$nb))\n    } else {col=1}\n    names(col) <- 1:(pars$nb+1)\n    plotSimmap(tree,colors=col)\n  }\n  ouMatrix <- function(vcvMatrix, alpha)\n    {  vcvDiag<-diag(vcvMatrix)\n       diagi<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag))\n       diagj<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag), byrow=T)\n       Tij = diagi + diagj - (2 * vcvMatrix)\n       vcvRescaled = (1 / (2 * alpha)) * exp(-alpha * Tij) * (1 - exp(-2 * alpha * vcvMatrix))\n       return(vcvRescaled)\n     }\n  pars$ntheta <- pars$nb+1\n  Sigma <- ouMatrix(vcv.phylo(tree),alpha)*sig2\n  height <- max(nodeHeights(tree))\n  TotExp <- exp(-height*alpha)\n  if(pars$ntheta >1 ){\n    E.th <- edgemap.W(pars,edge.map,tree,TotExp)%*%theta\n  } else {E.th <- edgemap.W(pars,edge.map,tree,TotExp)*theta}\n  X <- mvrnorm(1,E.th,Sigma)\n  print(regime.shifts)\n  if(phenogram==TRUE){\n    if(regime.shifts>0){\n      col <- c(\"#000000\",rainbow(regime.shifts))\n    } else {col <- 1}\n    names(col) <- 1:(regime.shifts+1)\n    phenogram(tree,X,colors=col,ftype=\"off\")\n  }\n  return(list(\"tree\"=tree,\"dat\"=X,\"pars\"=pars,\"emap\"=edge.map))\n}\n\n\nsetDefaults2 <- function (.name, ...) \n{\n    if (is.function(.name)) \n        .name <- deparse(substitute(.name))\n    if (!is.function(eval(parse(text = .name)))) \n        stop(\"argument '.name' must be a function\")\n    useDefaults(.name)\n    default.name <- paste(.name, \"Default\", sep = \".\")\n    old.defaults <- getDefaults(.name)\n    new.defaults <- c(...)\n    avail.defaults <- formals(.name)\n    matched.defaults <- list()\n    for (arg in names(new.defaults)) {\n        if (!is.na(pmatch(arg, names(avail.defaults)))) {\n            arg.name <- match.arg(arg, names(avail.defaults))\n            mc <- match.call()[[arg]]\n            if (typeof(mc) == \"language\") \n                mc <- eval(mc)\n            if (is.character(mc)) \n                new.defaults[[arg]] <- paste(\"'\", mc, \"'\", sep = \"\")\n            if (is.name(mc)) \n                new.defaults[[arg]] <- as.character(mc)\n            matched.defaults[[arg.name]] <- new.defaults[[arg]]\n            if (is.null(new.defaults[[arg]])) \n                old.defaults[[arg.name]] <- NULL\n        }\n        else {\n            warning(paste(sQuote(arg), \"was not set, possibly not a formal arg for\", \n                sQuote(.name)))\n        }\n    }\n    all.and.matched <- c(matched.defaults, old.defaults)\n    all.and.matched <- all.and.matched[unique(names(all.and.matched))]\n    if (length(all.and.matched) == 0) {\n        if (!is.null(getDefaults(.name))) \n            unsetDefaults(.name, confirm = FALSE)\n    }\n    else {\n        env <- environment(-1)\n        eval(parse(text = paste(\"options(\", default.name, \"=list(\", \n            paste(paste(names(all.and.matched), \"=\", lapply(all.and.matched, \n                function(x) {\n                  if (is.character(x)) {\n                    deparse(x)\n                  }\n                  else {\n                    x\n                  }\n                })), collapse = \",\"), \"))\", sep = \"\")), envir = env)\n    }\n}\n\n\n.eouprior <- function(tree,dat,dalpha=NULL,dsig2=NULL,dk=NULL,dtheta=NULL,dloc=NULL,bprior=\"equal\",param=list(\"alpha\"=NULL,\"sig2\"=NULL,\"theta\"=NULL,\"nb\"=NULL,\"loc\"=NULL),plot.prior=FALSE){\n  if(is.null(dat)){\n    dat <- rep(0,length(tree$tip.label))\n    names(dat) <- tree$tip.label\n  }\n  cache <- .prepare.ou.univariate(tree,dat)\n  #aFUN <- switch(dalpha,\"dunif\"=dunif,\"dgamma\"=dgamma,\"dtnorm\"=dtnorm,\"dbeta\"=dbeta,\"dexp\"=dexp,\"dlnorm\"=dlnorm)\n  #s2FUN <- switch(dsig2,\"dunif\"=dunif,\"dgamma\"=dgamma,\"dtnorm\"=dtnorm,\"dbeta\"=dbeta,\"dexp\"=dexp,\"dlnorm\"=dlnorm)\n  #kFUN <- switch(dk,\"dpois\"=dpois,\"dbinom\"=dbinom)\n  #tFUN <- switch(dtheta,\"dunif\"=dunif,\"dnorm\"=dnorm,\"dcauchy\"=dcauchy)\n  #lFUN <- switch(dloc,\"dunif\"=dunif,\"dbeta\"=dbeta,\"dtnorm\"=dtnorm)\n  dalpha <- if(is.null(dalpha)){\"dunif\"} else {dalpha} \n  dsig2 <- if(is.null(dsig2)){\"dunif\"} else {dsig2}\n  dtheta <- if(is.null(dtheta)){\"dunif\"} else {dtheta}\n  dloc <- if(is.null(dloc)) {\"dunif\"} else {dloc}\n  dk <- if(is.null(dk)){\"cdpois\"}else{dk}\n  if(bprior==\"equal\"){\n    bFUN <<- function(ntips,nb){\n      log(1/choose(2*ntips-2,nb))\n    } \n  }\n  if(bprior==\"equalnotips\"){\n    bFUN <<- function(ntips,nb){\n      log(1/choose(ntips-2,nb))\n    }\n  }\n  aFUN <<- get(dalpha)\n  s2FUN <<-get(dsig2)\n  tFUN <<- get(dtheta)\n  lFUN <<- get(dloc)\n  kFUN <<- get(dk)\n  if(is.null(param$theta)){\n    param$theta <- list(min=min(dat)-(max(dat)-min(dat))/2,max=max(dat)+(max(dat)-min(dat))/2)\n  }\n  if(is.null(param$alpha)){\n    param$alpha <- list(min=0,max=max(cache$nH)*log(2))\n  }\n  if(is.null(param$sig2)){\n    param$sig2 <- list(min=0,max=max(cache$nH)*log(2))\n  }\n  if(is.null(param$nb)){\n    param$nb <- list(lambda = 0.05*cache$ntips,kmax=cache$ntips)\n  }\n  if(is.null(param$loc)){\n    param$loc <- list()\n  }\n  prior.params <<- lapply(param,function(x){ x[['log']] = TRUE; x})\n  #setDefaults2(aFUN,prior.params$alpha)\n  #setDefaults2(s2FUN,prior.params$sig2)\n  #setDefaults2(kFUN,prior.params$nb)\n  #setDefaults2(tFUN,prior.params$theta)\n  #setDefaults2(lFUN,prior.params$loc)\n  aFUN<<- set.defaults(aFUN,defaults=prior.params$alpha)\n  s2FUN <<- set.defaults(s2FUN,defaults=prior.params$sig2)\n  kFUN<<-set.defaults(kFUN,defaults=prior.params$nb)\n  tFUN<<-set.defaults(tFUN,defaults=prior.params$theta)\n  lFUN<<-set.defaults(lFUN,defaults=prior.params$loc)\n  if(prior.params$nb$lambda>prior.params$nb$kmax){\n    stop(\"ERROR: Expected number of jumps greater than kmax, decrease lambda or increase kmax\")\n  }\n  priorFUN <- function(pars,emap,cache){\n    aprior <- aFUN(pars$alpha)\n    s2prior <- s2FUN(pars$sig2)\n    kprior <- kFUN(pars$nb)\n    tprior <- tFUN(pars$optima)\n    lprior <- sum(lFUN(emap$sh[emap$sh==1]))#*1/cache$edge.length[pars$shifts==1]))\n    bpr <- bFUN(length(cache$tip.label),pars$nb)\n    priorL <- aprior+s2prior+kprior+sum(tprior)+lprior+bpr\n    return(priorL)\n  }\n  if(plot.prior){\n    cache=.prepare.ou.univariate(tree,dat)\n    par(mfrow=c(2,2))\n\taxlimf <<- get(gsub('^[a-zA-Z]',\"q\",dalpha))\n\tsxlimf <<- get(gsub('^[a-zA-Z]',\"q\",dsig2))\n        axlim.pr <- prior.params$alpha[names(prior.params$alpha)!='log']\n        sxlim.pr <- prior.params$alpha[names(prior.params$sig2)!='log']\n        axlim.pr$log.p=FALSE\n\tsxlim.pr$log.p=FALSE\n\taxlimf <<- set.defaults(axlimf,defaults=axlim.pr)\n\tsxlimf <<- set.defaults(sxlimf,defaults=sxlim.pr)\n    curve(aFUN(x,log=FALSE),xlim=c(0,axlimf(.95)),main=\"ALPHA PRIOR\",ylab=\"density\")\n    curve(s2FUN(x,log=FALSE),xlim=c(0,sxlimf(.95)),main=\"SIGMA^2 PRIOR\",ylab=\"density\")\n    suppressWarnings(curve(exp(kFUN(round(x,0))),xlim=c(0,prior.params$nb$kmax),main=\"SHIFT PRIOR\",ylab=\"density\"))\n    curve(tFUN(x,log=FALSE),xlim=c(min(dat)-(max(dat)-min(dat))/2,max(dat)+(max(dat)+min(dat))/2),main=\"THETA PRIOR\",ylab=\"density\")\n  }\n  attributes(priorFUN) <- list(\"distributions\"=list(\"alpha\"=dalpha,\"sig2\"=dsig2,\"theta\"=dtheta,\"loc\"=dloc,\"nb\"=dk,\"bprior\"=bprior),\"parameters\"=param)\n  return(priorFUN)\n}\n\n###Quantitative genetic version\n#.QGprior <- function(tree,dat,dalpha=NULL,dsig2=NULL,dk=NULL,dtheta=NULL,dloc=NULL,bprior=\"equal\",param=list(\"alpha\"=NULL,\"sig2\"=NULL,\"theta\"=NULL,\"nb\"=NULL,\"loc\"=NULL),plot.prior=FALSE,model=NULL){\nQGprior <- function(tree,dists=list(\"dalpha\"=NULL,\"dsig2\"=NULL,\"dk\"=NULL,\"dtheta\"=NULL,\"dloc\"=NULL,bprior=\"equal\"),param=list(\"alpha\"=NULL,\"sig2\"=NULL,\"theta\"=NULL,\"nb\"=NULL,\"loc\"=NULL),plot.prior=FALSE,model=NULL){\n  nH <- max(nodeHeights(tree))\n  ntips <- length(tree$tip.label)\n\n  default.null <- list(dists=list(\"dalpha\"=\"dlnorm\",\"dsig2\"=\"dlnorm\",\"dk\"=\"cdpois\",\"dtheta\"=\"dnorm\",\"bprior\"=\"equal\",\"dloc\"=\"dunif\"),param=list(\"alpha\"=NULL,\"sig2\"=NULL,\"theta\"=NULL,\"nb\"=list(lambda=10,kmax=ntips/2),\"loc\"=NULL))\n  default.QG <- list(dists=list(\"dh2\"=\"dbeta\",\"dP\"=\"dlnorm\",\"dw2\"=\"dlnorm\",\"dNe\"=\"dlnorm\",\"dk\"=\"cdpois\",\"dtheta\"=\"dnorm\",\"bprior\"=\"equal\",\"dloc\"=\"dunif\"),param=list(\"h2\"=list(shape1=1,shape2=1),\"P\"=NULL,\"w2\"=NULL,\"Ne\"=NULL,\"theta\"=NULL,\"nb\"=list(lambda=10,kmax=ntips/2),\"loc\"=NULL))\n  default.OUrepar <- list(dists=list(\"dhalflife\"=\"dlnorm\",\"dVy\"=\"dlnorm\",\"dk\"=\"cdpois\",\"dtheta\"=\"dnorm\",\"bprior\"=\"equal\",\"dloc\"=\"dunif\"),param=list(\"halflife\"=list(\"meanlog\"=0.25,\"sdlog\"=1.5),\"Vy\"=list(\"meanlog\"=1,\"sdlog\"=2),\"P\"=NULL,\"w2\"=NULL,\"Ne\"=NULL,\"theta\"=NULL,\"loc\"=NULL))\n  \n  \n  if(model==\"OU\"){\n    notprovided <- setdiff(names(default.null$dist),names(dists))\n    pars.notprovided <- setdiff(names(default.null$param),names(param))\n    dists[notprovided] <- default.null$dists[notprovided]\n    param[pars.notprovided] <- default.null$param[pars.notprovided]\n    if(length(setdiff(names(default.null$param),names(param)))>0)\n      stop(\"Provided parameters are not in the model\")\n    if(length(setdiff(names(default.null$dists),names(dists)))>0)\n      stop(\"Provided parameters are not in the model\")\n  }\n  if(model==\"QG\"){\n    notprovided <- setdiff(names(default.QG$dist),names(dists))\n    pars.notprovided <- setdiff(names(default.QG$param),names(param))\n    dists[notprovided] <- default.QG$dists[notprovided]\n    param[pars.notprovided] <- default.QG$param[pars.notprovided]\n    if(length(setdiff(names(default.QG$param),names(param)))>0)\n      stop(\"Provided parameters are not in the model\")\n    if(length(setdiff(names(default.QG$dists),names(dists)))>0)\n      stop(\"Provided parameters are not in the model\")\n  }\n  if(model==\"OUrepar\"){\n    notprovided <- setdiff(names(default.OUrepar$dist),names(dists))\n    pars.notprovided <- setdiff(names(default.OUrepar$param),names(param))\n    dists[notprovided] <- default.OUrepar$dists[notprovided]\n    param[pars.notprovided] <- default.OUrepar$param[pars.notprovided]\n    if(length(setdiff(names(default.OUrepar$param),names(param)))>0)\n      stop(\"Provided parameters are not in the model\")\n    if(length(setdiff(names(default.OUrepar$dists),names(dists)))>0)\n      stop(\"Provided parameters are not in the model\")\n  }\n  if(dists$bprior==\"constrained\"){\n    bFUN<<- function(ntips,nb,constraints=NULL){\n      log(1/choose(sum(constraints),nb))\n    }\n    bFUN <<- set.defaults(bFUN,defaults=list(constraints=param$bprior))\n  }\n\n  if(dists$bprior==\"equal\"){\n    bFUN <<- function(ntips,nb){\n      log(1/choose(2*ntips-2,nb))\n    } \n  }\n  if(dists$bprior==\"equalnotips\"){\n    bFUN <<- function(ntips,nb){\n      log(1/choose(ntips-2,nb))\n    }\n  }\n  tFUN <<- get(dists$dtheta)\n  lFUN <<- get(dists$dloc)\n  kFUN <<- get(dists$dk)\n  if(is.null(param$theta)){\n    param$theta <- list(mean=0,sd=100)\n  }\n  if(is.null(param$nb)){\n    param$nb <- list(lambda = 0.05*ntips,kmax=ntips)\n  }\n  if(is.null(param$loc)){\n    param$loc <- list()\n  }\n  if(model==\"OU\"){\n    aFUN <<- get(dists$dalpha)\n    s2FUN <<-get(dists$dsig2)\n    if(is.null(param$alpha)){\n      param$alpha <- list(meanlog=0,sdlog=2)\n    }\n    if(is.null(param$sig2)){\n      param$sig2 <- list(meanlog=0,sdlog=2)\n    }\n    prior.params <<- lapply(param,function(x){ x[['log']] = TRUE; x})\n    aFUN<<- set.defaults(aFUN,defaults=prior.params$alpha)\n    s2FUN <<- set.defaults(s2FUN,defaults=prior.params$sig2)\n  }\n  if(model==\"QG\"){\n    h2FUN <<- get(dists$dh2)\n    VpFUN <<- get(dists$dP)\n    w2FUN <<- get(dists$dw2)\n    NeFUN <<- get(dists$dNe)\n    if(is.null(param$G)){\n      param$G <- list(shape1=1,shape2=1)\n    }\n    if(is.null(param$P)){\n      param$P <- list(meanlog=0,sdlog=2)\n    }\n    if(is.null(param$w2)){\n      param$w2 <- list(meanlog=2,sdlog=2)\n    }\n    if(is.null(param$Ne)){\n      param$Ne <- list(meanlog=10,sdlog=5)\n    }\n    prior.params <<- lapply(param,function(x){ x[['log']] = TRUE; x})\n    h2FUN <<- set.defaults(h2FUN,defaults=prior.params$h2)\n    VpFUN <<- set.defaults(VpFUN,defaults=prior.params$P)\n    w2FUN <<- set.defaults(w2FUN,defaults=prior.params$w2)\n    NeFUN <<- set.defaults(NeFUN,defaults=prior.params$Ne)\n  }\n  if(model==\"OUrepar\"){\n    t.5FUN <<- get(dists$dhalflife)\n    VyFUN <<- get(dists$dVy)\n    if(is.null(param$halflife)){\n      param$halflife <- list(shape1=0.25,shape2=1.5)\n    }\n    if(is.null(param$Vy)){\n      param$Vy <- list(meanlog=1,sdlog=2)\n    }\n    prior.params <<- lapply(param,function(x){ x[['log']] = TRUE; x})\n    t.5FUN <<- set.defaults(t.5FUN,defaults=prior.params$halflife)\n    VyFUN <<- set.defaults(VyFUN,defaults=prior.params$Vy)\n  }\n  \n  kFUN<<-set.defaults(kFUN,defaults=prior.params$nb)\n  tFUN<<-set.defaults(tFUN,defaults=prior.params$theta)\n  lFUN<<-set.defaults(lFUN,defaults=prior.params$loc)\n\n  #if(prior.params$nb$lambda>prior.params$nb$kmax){\n  #  stop(\"ERROR: Expected number of jumps greater than kmax, decrease lambda or increase kmax\")\n  #}\n  if(model==\"QG\"){\n    priorFUN <- function(pars,emap,cache){\n      h2prior <- h2FUN(pars$h2)\n      Pprior <- VpFUN(pars$P)\n      w2prior <- w2FUN(pars$w2)\n      Neprior <- NeFUN(pars$Ne)\n      kprior <- kFUN(pars$nb)\n      tprior <- tFUN(pars$optima)\n      lprior <- sum(lFUN(emap$sh[emap$sh==1]))#*1/cache$edge.length[pars$shifts==1]))\n      bpr <- bFUN(length(cache$tip.label),pars$nb)\n      priorL <- h2prior+Pprior+w2prior+Neprior+kprior+sum(tprior)+lprior+bpr\n      return(priorL)\n    }\n    if(plot.prior){\n      Pxlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dP))\n      w2xlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dw2))\n      Nexlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dNe))\n      Pxlim.pr <- prior.params$P[names(prior.params$P)!='log']\n      w2xlim.pr <- prior.params$w2[names(prior.params$w2)!='log']\n      Nexlim.pr <- prior.params$Ne[names(prior.params$Ne)!='log']\n      Pxlim.pr$log.p=FALSE\n      w2xlim.pr$log.p=FALSE\n      Nexlim.pr$log.p=FALSE\n      Pxlimf <<- set.defaults(Pxlimf,defaults=Pxlim.pr)\n      w2xlimf <<- set.defaults(w2xlimf,defaults=w2xlim.pr)\n      Nexlimf <<- set.defaults(Nexlimf,defaults=Nexlim.pr)\n      par(mfrow=c(2,3))\n      curve(h2FUN(x,log=FALSE),xlim=c(0,1),main=\"h^2 PRIOR\",ylab=\"density\")\n      curve(w2FUN(x,log=FALSE),xlim=c(0,w2xlimf(.95)),main=\"omega^2 PRIOR\",ylab=\"density\")\n      curve(VpFUN(x,log=FALSE),xlim=c(0,Pxlimf(.99)),main=\"Phenotypic variance PRIOR\",ylab=\"density\")\n      curve(NeFUN(x,log=FALSE),xlim=c(0,Nexlimf(.95)),main=\"Ne PRIOR\",ylab=\"density\")\n      suppressWarnings(curve(exp(kFUN(round(x,0))),xlim=c(0,prior.params$nb$kmax),main=\"SHIFT PRIOR\",ylab=\"density\"))\n      curve(tFUN(x,log=FALSE),xlim=c(-10,10),main=\"THETA PRIOR\",ylab=\"density\")\n    }\n  }\n  if(model==\"OU\"){\n    priorFUN <- function(pars,emap,cache){\n      aprior <- aFUN(pars$alpha)\n      s2prior <- s2FUN(pars$sig2)\n      kprior <- kFUN(pars$nb)\n      tprior <- tFUN(pars$optima)\n      lprior <- sum(lFUN(emap$sh[emap$sh==1]))#*1/cache$edge.length[pars$shifts==1]))\n      bpr <- bFUN(length(cache$tip.label),pars$nb)\n      priorL <- aprior+s2prior+kprior+sum(tprior)+lprior+bpr\n      return(priorL)\n    }\n    if(plot.prior){\n      par(mfrow=c(2,2))\n      axlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dalpha))\n      sxlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dsig2))\n      axlim.pr <- prior.params$alpha[names(prior.params$alpha)!='log']\n      sxlim.pr <- prior.params$sig2[names(prior.params$sig2)!='log']\n      axlim.pr$log.p=FALSE\n      sxlim.pr$log.p=FALSE\n      axlimf <<- set.defaults(axlimf,defaults=axlim.pr)\n      sxlimf <<- set.defaults(sxlimf,defaults=sxlim.pr)\n      curve(aFUN(x,log=FALSE),xlim=c(0,axlimf(.95)),main=\"ALPHA PRIOR\",ylab=\"density\")\n      curve(s2FUN(x,log=FALSE),xlim=c(0,sxlimf(.95)),main=\"SIGMA^2 PRIOR\",ylab=\"density\")\n      suppressWarnings(curve(exp(kFUN(round(x,0))),xlim=c(0,prior.params$nb$kmax),main=\"SHIFT PRIOR\",ylab=\"density\"))\n      curve(tFUN(x,log=FALSE),xlim=c(-10,10),main=\"THETA PRIOR\",ylab=\"density\")\n    }\n  }\n  if(model==\"OUrepar\"){\n    priorFUN <- function(pars,emap,cache){\n      t.5prior <- t.5FUN(pars$halflife)\n      Vyprior <- VyFUN(pars$Vy)\n      kprior <- kFUN(pars$nb)\n      tprior <- tFUN(pars$optima)\n      lprior <- sum(lFUN(emap$sh[emap$sh==1]))#*1/cache$edge.length[pars$shifts==1]))\n      bpr <- bFUN(length(cache$tip.label),pars$nb)\n      priorL <- t.5prior+Vyprior+kprior+sum(tprior)+lprior+bpr\n      return(priorL)\n    }\n    if(plot.prior){\n      par(mfrow=c(2,2))\n      t.5xlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dhalflife))\n      Vyxlimf <<- get(gsub('^[a-zA-Z]',\"q\",dists$dVy))\n      t.5xlim.pr <- prior.params$halflife[names(prior.params$halflife)!='log']\n      Vyxlim.pr <- prior.params$Vy[names(prior.params$Vy)!='log']\n      t.5xlim.pr$log.p=FALSE\n      Vyxlim.pr$log.p=FALSE\n      t.5xlimf <<- set.defaults(t.5xlimf,defaults=t.5xlim.pr)\n      Vyxlimf <<- set.defaults(Vyxlimf,defaults=Vyxlim.pr)\n      curve(t.5FUN(x,log=FALSE),xlim=c(0,t.5xlimf(.95)),main=\"Phylogenetic half-life PRIOR\",ylab=\"density\")\n      curve(VyFUN(x,log=FALSE),xlim=c(0,Vyxlimf(.95)),main=\"Stationary Variance PRIOR\",ylab=\"density\")\n      suppressWarnings(curve(exp(kFUN(round(x,0))),xlim=c(0,prior.params$nb$kmax),main=\"SHIFT PRIOR\",ylab=\"density\"))\n      curve(tFUN(x,log=FALSE),xlim=c(-10,10),main=\"THETA PRIOR\",ylab=\"density\")\n    }\n  }\n  \n  attributes(priorFUN) <- list(\"parnames\"=names(param),\"distributions\"=dists,\"parameters\"=param)\n  return(priorFUN)\n}\n\nQG.alpha <- function(pars){\n  pars$h2*pars$P/(pars$P+pars$w2*pars$P)\n}\nQG.sig2 <- function(pars){\n  (pars$h2*pars$P)/pars$Ne\n}\n\nOU.repar <- function(pars){\n  alpha <- log(2)/pars$halflife\n  sig2 <- (2*log(2)/(pars$halflife))*pars$Vy\n  return(list(alpha=alpha,sig2=sig2))\n}\n\n.priorsim <- function(.prior,phy,plot=TRUE,pars=\"all\",n=NULL){\n  if(class(phy)==\"phylo\"){\n    ntips <- length(phy$tip.label)\n    X <- rep(1,ntips)\n    names(X) <- phy$tip.label\n    cache <- .prepare.bm.univariate(phy,X)\n    phy <- cache$phy\n   } else {\n     cache <- phy\n     phy <- cache$phy\n     ntips <- length(phy$tip.label)\n   }\n  dist <- attributes(.prior)$distributions\n  prior.params <- attributes(.prior)$parameters\n  bprior <- dist$bprior\n  rdist <- lapply(dist,function(x) gsub('^[a-zA-Z]',\"r\",x))\n  aRAND <<- get(rdist$dalpha)\n  s2RAND <<- get(rdist$dsig2)\n  tRAND <<- get(rdist$dtheta)\n  lRAND <<- get(rdist$dloc)\n  kRAND <<- get(rdist$dk)\n  aRAND <<- set.defaults(aRAND,defaults=prior.params$alpha)\n  s2RAND <<- set.defaults(s2RAND,defaults=prior.params$sig2)\n  kRAND <<- set.defaults(kRAND,defaults=prior.params$nb)\n  tRAND <<- set.defaults(tRAND,defaults=prior.params$theta)\n  lRAND <<- set.defaults(lRAND,defaults=prior.params$loc)\n  if(pars==\"alpha\"){\n    return(aRAND(n))\n  }\n  if(pars==\"sig2\"){\n    return(s2RAND(n))\n  }\n  if(pars==\"k\"){\n    return(kRAND(n))\n  }\n  if(pars==\"optima\"){\n    return(tRAND(n))\n  }\n  if(pars==\"all\"){\n    nb <- kRAND(1)\n    phy$maps <- lapply(phy$edge.length,function(x){names(x) <- 1; x})\n    if(nb>0){\n      if(bprior==\"equalnotips\"){plim <- ntips} else {plim <- 0}\n      pp <- rep(1,2*ntips-2-plim)\n      pp <- pp/sum(pp)\n      sb <- sample((1:length(phy$edge.length))[phy$edge[,2]>plim],nb,replace=FALSE,prob=pp)\n      sb <- sb[rev(order(sb))]\n      sl <- lRAND(nb)*phy$edge.length[sb]\n      phy$maps[sb] <- lapply(1:nb,function(x){y <- c(sl[x],phy$maps[[sb[x]]]-sl[x]);names(y)[2] <- x+1 ;y})\n      shifts <- sapply(phy$maps,length)-1\n      nopt <- rep(1,length(shifts))\n      opt <- 1\n      for(i in length(shifts):1){\n        if(shifts[i]==1){\n          opt <- opt+1\n          nopt[phy$edge[i,2]] <- opt\n        } else {\n          nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n        }\n      }\n      phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[1] <- nopt[phy$edge[x,1]];phy$maps[[x]] })\n      phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[length(phy$maps[[x]])] <- nopt[phy$edge[x,2]];phy$maps[[x]] })\n      S <- phy$edge.length\n      S[sb] <- sl\n      S2 <- rep(0,length(shifts))\n      S2[sb] <- phy$edge.length[sb]-sl\n      edge.map <- data.frame(phy$edge,nopt[phy$edge[,1]],nopt[phy$edge[,2]],shifts,phy$tip.label[phy$edge[,2]],S,S2,phy$edge.length)\n      colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n                                        #names(edge.map) <- c(\"edge[,1]\",\"edge[,2]\",\"theta1\",\"theta2\",\"shift\",\"tip.label\",\"edge.length\")\n    } else {\n      edge.map <- data.frame(phy$edge,1,1,0,phy$tip.label[phy$edge[,2]],phy$edge.length,0,phy$edge.length)\n      colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n    }\n    if(plot==TRUE){\n      if(nb>0){\n        col <- c(\"#000000\",rainbow(nb))\n      } else {col <- 1}\n      names(col) <- 1:(nb+1)\n      plotSimmap(phy,colors=col,fsize=0.7)\n    }\n    return(list(\"pars\"=list(\"alpha\"=aRAND(1),\"sig2\"=s2RAND(1),\"nb\"=nb,\"ntheta\"=nb+1,\"optima\"=tRAND(nb+1)),\"tree\"=phy,\"emap\"=edge.map))  \n  }\n}\n\nsplitmerge.emap <- function(emap,pars,cache,plim=plim,d,move=NULL){\n  j <- round(runif(1,0.5,2*cache$ntips-2+0.5),0)\n  emap.new <- emap\n  pars.new <- pars\n  b <- dim(emap)[1]\n  if(emap$sh[j]==1){\n    decision <- \"death\"\n    emap.new$sh[j] <- 0\n    emap.new$r1[j] <- emap.new$r[j]\n    emap.new$r2[j] <- 0\n    old.t <- emap.new$t2[j]\n    new.t <- emap.new$t1[j]\n    t1W <- sum(emap.new$r1[emap.new$t1==new.t]+emap.new$r2[emap.new$t1==new.t])\n    t2W <- sum(emap.new$r1[emap.new$t2==old.t]+emap.new$r2[emap.new$t2==old.t])\n    r <- t2W/(t1W+t2W)\n    emap.new$t1[emap.new$t1==old.t] <- new.t\n    emap.new$t2[emap.new$t2==old.t] <- new.t\n    if(sum(emap.new$t1>old.t)>0){\n      emap.new$t1[emap.new$t1>old.t] <-  emap.new$t1[emap.new$t1>old.t]-1\n    }\n    if(sum(emap.new$t2>old.t)>0){\n      emap.new$t2[emap.new$t2>old.t] <-  emap.new$t2[emap.new$t2>old.t]-1\n    }\n    pars.new$optima[new.t] <- (1-r)*pars.new$optima[new.t]+(r)*pars.new$optima[old.t]\n    pars.new$optima <- pars.new$optima[-old.t]\n    pars.new$ntheta <- pars$ntheta-1\n    pars.new$nb <- pars$nb-1\n    hr <- ifelse(pars.new$nb==pars$nb-1,log(1/d),log(0))\n  }\n  if(emap$sh[j]==0){\n    decision <- \"birth\"\n    emap.new$sh[j] <- 1\n    emap.new$t2[j] <- pars$ntheta+1\n    u <- runif(1)\n    emap.new$r1[j] <- u*emap.new$r[j]\n    emap.new$r2[j] <- (1-u)*emap.new$r[j]\n    pars.new$ntheta <- pars$ntheta+1\n    pars.new$nb <- pars$nb+1\n    t1W <- sum(emap.new$r1[emap.new$t1==emap.new$t1[j]]+emap.new$r2[emap.new$t1==emap.new$t1[j]])\n    t2W <- sum(emap.new$r1[emap.new$t2==emap.new$t2[j]]+emap.new$r2[emap.new$t2==emap.new$t2[j]])\n    r <- t2W/(t1W+t2W)\n    u <- runif(1,-0.5,0.5)*d\n    pars.new$optima[emap.new$t1[j]] <- pars$optima[emap.new$t1[j]]-u*r\n    pars.new$optima[emap.new$t2[j]] <- pars$optima[emap.new$t1[j]]+u*(1-r)   \n    if(emap.new$e2[j]>cache$ntips){\n      nopt <- rep(1,b)\n      nopt[emap.new$e2] <- emap.new$t2\n      for(i in (j-1):1){\n        if(emap.new$sh[i]==0){\n          nopt[emap.new$e2[i]] <- nopt[emap.new$e1[i]]\n        }\n      }\n      emap.new$t1 <- nopt[emap.new$e1]\n      emap.new$t2 <- nopt[emap.new$e2]\n    }\n    hr <-  ifelse(pars.new$nb==pars$nb+1,log(d),log(0))\n  }\n  list(pars=pars.new,emap=emap.new,decision=decision,branch=j,hr=hr)\n}\n\npull.emap <- function(i,chain,cache){\n  sb <- chain$branch.shift[[i]]\n  t2 <- chain$t2[[i]]\n  sl <- chain$location[[i]]\n  phy <- cache$phy\n  shifts <- rep(0,length(cache$edge.length))\n  shifts[sb] <- 1\n  nopt <- rep(1,length(shifts)+1)\n  opt <- 1\n  j <- length(t2)\n  phy$maps <- lapply(phy$edge.length,function(x){names(x) <- 1; x})\n  if(length(sb)>0){\n    phy$maps[sb] <- lapply(1:length(sb),function(x){y <- c(sl[x],phy$maps[[sb[x]]]-sl[x]);names(y)[2] <- t2[x] ;y})\n    for(i in length(shifts):1){\n      if(shifts[i]==1){\n        opt <- t2[j]\n        nopt[phy$edge[i,2]] <- opt\n        j <- j-1\n      } else {\n      nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n    }\n    }\n  }\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[1] <- nopt[phy$edge[x,1]];phy$maps[[x]] })\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[length(phy$maps[[x]])] <- nopt[phy$edge[x,2]];phy$maps[[x]] })\n  S <- phy$edge.length\n  S[sb] <- phy$edge.length[sb]-sl\n  S2 <- rep(0,length(shifts))\n  S2[sb] <- sl\n  edge.map <- data.frame(phy$edge,nopt[phy$edge[,1]],nopt[phy$edge[,2]],shifts,phy$tip.label[phy$edge[,2]],S,S2,phy$edge.length)\n  colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(list(phy=phy,emap=edge.map))\n}\n\nread.emap <- function(sb,sl,t2,phy){\n  shifts <- rep(0,length(phy$edge.length))\n  shifts[sb] <- 1\n  nopt <- rep(1,length(shifts))\n  opt <- 1\n  j <- 1\n  phy$maps <- lapply(phy$edge.length,function(x){names(x) <- 1; x})\n  if(length(sb)>0){\n    phy$maps[sb] <- lapply(1:length(sb),function(x){y <- c(sl[x],phy$maps[[sb[x]]]-sl[x]);names(y)[2] <- x+1 ;y})\n    for(i in length(shifts):1){\n      if(shifts[i]==1){\n        opt <- t2[j]\n        nopt[phy$edge[i,2]] <- opt\n        j <- j+1\n      } else {\n      nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n    }\n    }\n  }\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[1] <- nopt[phy$edge[x,1]];phy$maps[[x]] })\n  phy$maps <- lapply(1:length(shifts),function(x){ names(phy$maps[[x]])[length(phy$maps[[x]])] <- nopt[phy$edge[x,2]];phy$maps[[x]] })\n  S <- phy$edge.length\n  S[sb] <- sl\n  S2 <- rep(0,length(shifts))\n  S2[sb] <- phy$edge.length[sb]-sl\n  edge.map <- data.frame(phy$edge,nopt[phy$edge[,1]],nopt[phy$edge[,2]],shifts,phy$tip.label[phy$edge[,2]],S,S2,phy$edge.length)\n  colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(list(phy=phy,emap=edge.map))\n}\n\nread.thetas <- function(sb,sl,t2,phy){\n  shifts <- rep(0,length(phy$edge.length))\n  shifts[sb] <- 1\n  nopt <- rep(1,length(shifts))\n  opt <- 1\n  j <- 1\n  for(i in length(shifts):1){\n    if(shifts[i]==1){\n      opt <- t2[j]\n      nopt[phy$edge[i,2]] <- opt\n      j <- j+1\n    } else {\n      nopt[phy$edge[i,2]] <- nopt[phy$edge[i,1]]\n    }\n  }\n  thetas <- data.frame(nopt[phy$edge[,1]],nopt[phy$edge[,2]])\n  colnames(thetas)= c(\"t1\",\"t2\")\n  return(thetas)\n}\n\nemap2simmap <- function(emap,tree){\n  foo <- function(x){\n    tmp <- unlist(emap[x,c('r1','r2')])\n    names(tmp) <- c(emap$t1[x],emap$t2[x])\n    tmp[tmp>0]\n  }\n  nb <- sum(emap$sh)\n  if(nb>0){\n      col <- c(\"#000000\",rainbow(nb))\n    } else {col <- 1}\n    names(col) <- 1:(nb+1)\n  tree$maps <- lapply(1:dim(emap)[1],foo)\n  tree$col <- col\n  tree\n}\n\n\n\n\n###Generic multiplier proposal\n.multiplierProposal <- function(move,cache,pars,emap,d){\n  m <- exp(d*(runif(1)-0.5))\n  prop <- pars[[move]]*m\n  lnHastingsRatio <- log(m)\n  new.pars <- pars\n  new.pars[[move]] <- prop\n  #prior1 <- .prior(pars,emap,cache)\n  #prior2 <- .prior(new.pars,emap,cache)\n  return(list(\"pars\"=new.pars,\"emap\"=emap,\"par\"=ifelse(class(move)==\"numeric\",names(pars)[move],move),\"hr\"=lnHastingsRatio))\n}\n\n###adjust alpha\n.adjustAlpha <- function(cache,pars,emap,d,type=\"multiplier\",move=NULL){\n  alpha <- pars$alpha\n  if(type==\"multiplier\"){\n    m <- exp(d*(runif(1)-0.5))\n    prop <- alpha*m\n    lnHastingsRatio <- log(m)\n    new.pars <- pars\n    new.pars$alpha <- prop\n    #pr <- .prior(new.pars,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"pars\" = new.pars,\"emap\"=emap, \"hr\"=lnHastingsRatio))\n  }\n}\n\n###adjust sigma2\n.adjustSig2 <- function(cache,pars,emap,d,type=\"multiplier\",move=NULL){\n  sig2 <- pars$sig2\n  if(type==\"multiplier\"){\n    ##Generate sliding-window proposal\n    m <- exp(d*(runif(1)-0.5))\n    prop <- sig2*m\n    lnHastingsRatio <-log(m) \n    new.pars <- pars\n    new.pars$sig2 <- prop\n    #pr <- .prior(new.pars,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"pars\" = new.pars,\"emap\"=emap, \"hr\"=lnHastingsRatio))\n  }\n}\n\n\n##\"H\" move. Adjust a randomly selected theta parameter\n.adjustTheta <- function(cache, pars, emap, d, type=\"slidingwindow\",move=NULL){\n  j <- sample(1:pars$ntheta,1)\n  if(type==\"slidingwindow\"){\n    ##Generate sliding-window proposal\n    prop <- d*(runif(1)-0.5)+pars$optima[j]\n    lnHastingsRatio <- 0\n    new.pars <- pars\n    new.pars$optima[j] <- prop\n    #pr <- .prior(new.pars,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"optima\" = j, \"prop\" = prop, \"hr\"=lnHastingsRatio,  \"pars\" = new.pars,\"emap\"=emap))\n  }\n  if(type==\"multiplier\"){\n    ##Generate multiplier proposal\n    m <- exp(d*(runif(1)-0.5))\n    prop <- pars$optima[j]*m\n    lnHastingsRatio <- log(m)\n    new.pars <- pars\n    new.pars$optima[j] <- prop\n    #pr <- .prior(new.pars,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"optima\" = j, \"prop\" = prop, \"hr\"=lnHastingsRatio, \"pars\" = new.pars,\"emap\"=emap))\n  }\n}\n\n.adjustPos <- function(cache,pars,emap,d,memory=TRUE,move=NULL){\n  j <- sample(1:length(emap$sh),1,prob=emap$sh/sum(emap$sh))\n  if (memory){\n    v <- runif(1,-0.5,0.5)*d\n    lim <- c(0,emap$r[j])\n    prop <- emap$r1[j]+v\n    if (prop <= lim[1]){\n      nv <- (lim[1]-prop)%%(lim[2]-lim[1])\n      prop <- lim[1]+nv\n    }\n    if (prop >= lim[2]){\n      nv <- (prop-lim[2])%%(lim[2]-lim[1])\n      prop <- lim[2]-nv\n    }\n    lnHastingsRatio <- 0\n  } else {\n    lim <- c(0,emap$r[j])\n    prop <- runif(1,lim[1],lim[2])\n    lnHastingsRatio <- 0\n  }\n  emap.new <- emap\n  emap.new$r1[j] <- prop\n  emap.new$r2[j] <- emap$r[j]-prop\n  #pr <- .prior(pars,emap.new,cache)-.prior(pars,emap,cache)\n  return(list(\"pars\"=pars,\"emap\"=emap.new,\"branch\"=j,\"hr\"=lnHastingsRatio))\n}\n\n.slideBranch <- function(cache,pars,emap,d,move=NULL){\n  slides <- count.slides(pars,emap)\n  j <- sample(1:pars$nb,1,replace=FALSE,prob=slides$p)\n  branch <- slides$branches[j]\n  decision <- sample(c('slideup','slidedown'),1,prob=c(slides$up[j],slides$down[j]))\n  if(decision=='slideup'){\n    new.emap <- emap\n    new.branch <- sample(slides$fbranch[[j]],1)\n    ##modify the new branch\n    new.emap$t1[new.branch] <- emap$t1[branch]\n    new.emap$sh[new.branch] <- 1\n    u <- runif(1)\n    new.emap$r1[new.branch] <- emap$r[new.branch]*u\n    new.emap$r2[new.branch] <- emap$r[new.branch]-new.emap$r1[new.branch]\n    ##modify the old branch\n    new.emap$t2[branch] <- emap$t1[branch]\n    new.emap$sh[branch] <- new.emap$r2[branch] <- 0\n    new.emap$r1[branch] <- emap$r[branch]\n\n    t1 <- emap$t1[branch]\n    t2 <- emap$t2[branch]\n    nn <- emap$e2[branch]\n    nexc <- emap$e2[new.branch]\n    desc <- cache$desc$adesc[[nn]]\n    desc.exc <- cache$desc$adesc[[nexc]]\n    rowdesc <- which(new.emap$e2 %in% desc[!(desc %in% c(nexc,desc.exc))])\n    new.emap$t1[rowdesc][new.emap$t1[rowdesc]==t2] <- t1\n    new.emap$t2[rowdesc][new.emap$t2[rowdesc]==t2] <- t1\n    rev.slides <- count.slides(pars,new.emap)\n    lnhr <- log((1/rev.slides$total)/(1/slides$total))\n  }\n  if(decision=='slidedown'){\n    new.emap <- emap\n    new.branch <- slides$abranch[[j]]\n    new.emap$t2[new.branch] <- new.emap$t1[branch] <- emap$t2[branch]\n    new.emap$sh[new.branch] <- 1\n    new.emap$sh[branch] <- new.emap$r2[branch] <- 0\n    new.emap$r1[branch] <- emap$r[branch]\n    u <- runif(1)\n    new.emap$r1[new.branch] <- emap$r[new.branch]*u\n    new.emap$r2[new.branch] <- emap$r[new.branch]-new.emap$r1[new.branch]\n    t1 <- emap$t1[branch]\n    t2 <- emap$t2[branch]\n    nn <- emap$e2[new.branch]\n    desc <- cache$desc$adesc[[nn]]\n    rowdesc <- which(new.emap$e2 %in% desc)\n    new.emap$t1[rowdesc][new.emap$t1[rowdesc]==t1] <- t2\n    new.emap$t2[rowdesc][new.emap$t2[rowdesc]==t1] <- t2\n    rev.slides <- count.slides(pars,new.emap)\n    lnhr <- log((1/rev.slides$total)/(1/slides$total))\n  }\n  return(list(\"pars\"=pars,\"emap\"=new.emap,\"hr\"=lnhr,\"decision\"=decision,\"branch\"=branch))\n}\n\ncount.slides <- function(pars,emap){\n  forward.nodes <- emap$e2[emap$sh==1]\n  backward.nodes <- emap$e1[emap$sh==1]\n  shifts <- which(emap$sh==1)\n  forward.branches <- lapply(forward.nodes,function(x){ b <- which(emap$e1==x) ; b[!(b %in% shifts)]})\n  backward.branches <- lapply(backward.nodes,function(x){ b <- which(emap$e2==x) ; b[!(b %in% shifts)]})\n  up <- sapply(forward.branches,length)\n  down <- sapply(backward.branches,length)\n  total <- sum(up) + sum(down)\n  slide.p <- (up+down)/total\n  return(list(\"p\"=slide.p,\"up\"=up,\"down\"=down,\"total\"=total,\"branches\"=shifts,\"fbranch\"=forward.branches,\"abranch\"=backward.branches))\n}\n\n###Map error checking\ncheck.maps <- function(pars){\n  mapnames <- lapply(pars$maps,names)\n  if(any(sapply(mapnames,length)!=sapply(mapnames,function(x) length(unique(x))))){\n    print(\"Error\")\n    break\n}\n}\n\n###Initiate the control list\ninit.control <- function(emap){\n  bk <- 0.45\n  R <-1-bk\n  if (sum(emap$sh)== 0){\n    pk <- 0\n    udk <- 0\n    sk <- R/9\n    ak <- tk <- 4*R/9\n  } else {\n    if (sum(1-emap$sh)==0){\n      udk <- 0\n      ak <- tk <-4*R/10\n      sk <- R/10\n      pk <- R/10\n    } else {\n      udk <- R/10\n      ak <- tk <-3.5*R/10\n      sk <- R/10\n      pk <- R/10\n    }\n  }\n  return(list(\"pk\" = pk,\"bk\" = bk,\"ak\"=ak,\"sk\"=sk,\"tk\"=tk,\"udk\"=udk))\n}\ntune.D <- function(D,accept,accept.type){\n  tuning.samp <- (length(accept)/2):length(accept)\n  acc <- tapply(accept[tuning.samp],accept.type[tuning.samp],mean)\n  acc.length <- tapply(accept[tuning.samp],accept.type[tuning.samp],length)\n  acc.tune <- acc/0.25\n  acc.tune[acc.tune<0.5] <- 0.5\n  acc.tune[acc.tune>2] <- 2\n  D$ak <- acc.tune['alpha']*D$ak\n  D$sk <- acc.tune['sig2']*D$sk\n  D$tk <- acc.tune['theta']*D$tk\n  D$bk <- D$tk*2\n  D <- lapply(D,function(x){ names(x) <- NULL; x})\n  return(list(\"D\"=D,\"acc.tune\"=acc.tune))\n}\n\noptima.ages <- function(pars,tree){\n  reg <- sapply(tree$maps,function(x) names(x)[length(x)])\n  adj <- sapply(tree$maps,function(x) ifelse(length(x)>1,x[1],0))\n  abs.age <- nodeHeights(tree)[,1]+adj\n  start <- tapply(abs.age,reg,min)\n  end <- rep(max(abs.age),pars$ntheta)+1\n  o <- as.character(1:pars$ntheta)\n  names(end) <- names(start)\n  return(cbind(start[o],end[o]))\n}\n\nregime.plot <- function(pars,tree,cols,type='rect',model=\"OU\"){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  OA <- optima.ages(pars,tree)\n  CIU95 <- pars$optima+2*sqrt(pars$sig2/(2*pars$alpha))\n  CIL95 <- pars$optima-2*sqrt(pars$sig2/(2*pars$alpha))\n  if(type==\"lines\"){\n    for(i in 1:pars$ntheta){\n      lines(c(OA[i,1],OA[i,2]),rep(pars$optima[i],2),col=cols[i],lwd=3)\n      lines(c(OA[i,1],OA[i,2]),rep(CIU95[i],2),col=cols[i],lwd=1.25,lty=2)\n      lines(c(OA[i,1],OA[i,2]),rep(CIL95[i],2),col=cols[i],lwd=1.25,lty=2)\n    }\n  }\n  if(type==\"rect\"){\n      for(i in 1:pars$ntheta){\n      rect(OA[i,1],CIL95[i],OA[i,2],CIU95[i],col=cols[i],border=NA)\n    }\n  }\n  if(type==\"density\"){\n    ylim <- par('usr')[3:4]\n    for(i in 1:pars$ntheta){\n      x <- seq(OA[i,1],OA[i,2],length=10)\n      y <- seq(ylim[1],ylim[2],length=100)\n      Z <- matrix(nrow=length(x),ncol=length(y))\n      for(j in 1:length(x)){\n        Z[j,] <- dnorm(y,pars$optima[i],sqrt(pars$sig2/(2*pars$alpha)))\n      }\n      if(sum(Z)!=0){\n        densregion(x,y,Z,colmax=cols[i],colmin=\"transparent\")\n      }\n      lines(c(OA[i,1],OA[i,2]),rep(pars$optima[i],2),col=cols[i],lwd=2)\n     }\n  }\n}\n \nmakeTransparent <- function(someColor, alpha=100)\n{\n  newColor<-col2rgb(someColor)\n  apply(newColor, 2, function(curcoldata){rgb(red=curcoldata[1], green=curcoldata[2],\n    blue=curcoldata[3],alpha=alpha, maxColorValue=255)})\n}\n\nrjmcmc.ou <- function(tree,dat,SE=NA,ngen=100000,samp=10,chunk=100,control=NULL,tuning=NULL,new.dir=FALSE,plot=TRUE,plot.freq=500,outname=\"bayou\",ticker.freq=1000,tuning.int=c(0.1,0.2,0.3),startpar=NULL){\n  cache <- .prepare.ou.univariate(tree,dat)\n  if(is.null(startpar)){\n    startpar <- .priorsim(.prior,tree,plot=FALSE)\n  }\n  if(is.null(control)){\n    ct <<- init.control(startpar$edge.map)\n  } else {ct <- control}\n  if(is.null(tuning)){\n    D <- list(\"bk\"=5, \"ak\"= 5,\"sk\"= 1,\"tk\"= 10,\"pk\"= mean(cache$edge.length)/10)\n  } else { D <- tuning}\n  if(attributes(.prior)$distributions$bprior==\"equal\"){\n    plim <- 0\n  } else {plim <- cache$ntips}\n  if(new.dir){\n    dir.name <- paste(sample(LETTERS,10),collapse=\"\")\n    dir <- paste(getwd(),\"/\",dir.name,\"/\",sep=\"\")\n    dir.create(dir)\n    setwd(dir)\n  } else {\n    dir <- getwd()\n    dir.name <- sapply(strsplit(dir,'/'),function(x) x[length(x)])\n    }\n  #mapst1 <- file(\"mapst1.dta\")\n  #mapst2 <- file(\"mapst2.dta\",\"w\")\n  #mapsr2 <- file(\"mapsr2.dta\",\"w\")\n  mapsb <- file(paste(outname,\".mapsb\",sep=\"\"),open=\"w\")\n  mapsr2 <- file(paste(outname,\".mapsr2\",sep=\"\"),open=\"w\")\n  mapst2 <- file(paste(outname,\".mapst2\",sep=\"\"),open=\"w\")\n  pars.output <- file(paste(outname,\".pars\",sep=\"\"),open=\"w\")\n  oldpar <- startpar$pars\n  oldmap <- startpar$edge.map\n  #chunk.mapst1 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n  #chunk.mapst2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n  #chunk.mapsr2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n  chunk.branch <<- list()\n  chunk.r2 <<- list()\n  chunk.t2 <<- list()\n  out <<- list()\n  oll  <- .emOU.lik(oldpar,oldmap,cache,dat)$loglik\n  pr1 <- .prior(oldpar,oldmap,cache)\n  store <- function(i,pars,maps,cache,dat,ll,pr,samp,chunk){\n    #oll <- .emOU.lik(pars,maps,cache,dat)\n    if(i%%samp==0){\n      j <- (i/samp)%%chunk\n      if(j!=0 & i>0){\n        chunk.branch[[j]] <<- (1:length(maps$sh))[maps$sh==1]\n        chunk.t2[[j]] <<- maps$t2[maps$sh==1]\n        chunk.r2[[j]] <<- maps$r2[maps$sh==1]\n        parline <- unlist(pars)\n        parline <- parline[c('alpha','sig2','nb','ntheta',grep(\"optima\",names(parline),value=TRUE))]\n        out[[j]] <<- c(i,ll,pr,parline)\n      } else {\n        #chunk.mapst1[chunk,] <<- maps$t1\n        #chunk.mapst2[chunk,] <<- maps$t2\n        #chunk.mapsr2[chunk,] <<- maps$r2\n        chunk.branch[[chunk]] <<- (1:length(maps$sh))[maps$sh==1]\n        chunk.t2[[chunk]] <<- maps$t2[maps$sh==1]\n        chunk.r2[[chunk]] <<- maps$r2[maps$sh==1]\n        parline <- unlist(pars)\n        parline <- parline[c('alpha','sig2','nb','ntheta',paste('optima',1:(length(parline)-4),sep=\"\"))]\n        out[[chunk]] <<- c(i,ll,pr,parline)\n        #write.table(chunk.mapst1,file=mapst1,append=TRUE,col.names=FALSE,row.names=FALSE)\n        #write.table(chunk.mapst2,file=mapst2,append=TRUE,col.names=FALSE,row.names=FALSE)\n        #write.table(chunk.mapsr2,file=mapsr2,append=TRUE,col.names=FALSE,row.names=FALSE)\n        lapply(out,function(x) cat(c(x,\"\\n\"),file=pars.output,append=TRUE))\n        lapply(chunk.branch,function(x) cat(c(x,\"\\n\"),file=mapsb,append=TRUE))\n        lapply(chunk.t2,function(x) cat(c(x,\"\\n\"),file=mapst2,append=TRUE))\n        lapply(chunk.r2,function(x) cat(c(x,\"\\n\"),file=mapsr2,append=TRUE))\n        #chunk.mapst1 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n        #chunk.mapst2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n        #chunk.mapsr2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n        #out <<- list()\n        chunk.branch <<- list()\n        chunk.r2 <<- list()\n        chunk.t2 <<- list()\n        out <<- list()\n      }\n    }\n  }\n  #store(oldpar,oldmap,cache,dat,oll,pr1)\n  accept.type <<- NULL\n  accept <<- NULL\n  tr <- emap2simmap(oldmap,cache$phy)\n  tcols <- makeTransparent(tr$col,alpha=100)\n  phenogram(tr,dat,colors=tr$col,ftype=\"off\")\n  plot.dim <- list(par('usr')[1:2],par('usr')[3:4])\n  tuning.int <- round(tuning.int*ngen,0)\n  \n  for (i in 1:ngen){\n    u <- runif(1)\n    if (u < ct$bk){\n      prop <- splitmerge.emap(oldmap,oldpar,cache,plim,D$bk)\n      accept.type <<- c(accept.type,prop$decision)\n      pr2 <- .prior(prop$pars,prop$emap,cache)\n      hr <- prop$lnHastingsRatio\n      new <- .emOU.lik(prop$pars,prop$emap,cache,dat,SE=0)\n      nll <- new$loglik\n      if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n        oldmap <- prop$emap\n        oldpar <- prop$pars\n        pr1 <- pr2\n        oll <- nll\n        accept <<- c(accept,1)\n      } else {\n        accept <<- c(accept,0)\n      }\n      store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n    } else {\n      if(u < ct$bk+ct$tk){\n        prop <- .adjustTheta(cache,oldpar,oldmap,D$tk)\n        accept.type <<- c(accept.type,'theta')\n        pr2 <- .prior(prop$pars,oldmap,cache)\n        hr <- 0\n        new <- .emOU.lik(prop$pars,oldmap,cache,dat,SE=0)\n        nll <- new$loglik\n        if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n          oldpar <- prop$pars\n          pr1 <- pr2\n          oll <- nll\n          accept <<- c(accept,1)\n        } else {\n          accept <<- c(accept,0)\n        }\n        store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n      } else {\n        if(u < ct$bk+ct$tk+ct$ak){\n          prop <- .adjustAlpha(cache,oldpar,oldmap,D$ak)\n          accept.type <<- c(accept.type,'alpha')\n          pr2 <- .prior(prop$pars,oldmap,cache)\n          hr <- prop$hr\n          new <- .emOU.lik(prop$pars,oldmap,cache,dat,SE=0)\n          nll <- new$loglik\n          if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n            oldpar <- prop$pars\n            pr1 <- pr2\n            oll <- nll\n            accept <<- c(accept,1)\n          } else {\n            accept <<- c(accept,0)\n          }\n          store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n        } else {\n          if(u < ct$bk+ct$tk+ct$ak+ct$sk){\n            prop <- .adjustSig2(cache,oldpar,oldmap,D$sk)\n            accept.type <<- c(accept.type,'sig2')\n            pr2 <- .prior(prop$pars,oldmap,cache)\n            hr <- prop$hr\n            new <- .emOU.lik(prop$pars,oldmap,cache,dat,SE=0)\n            nll <- new$loglik\n            if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n              oldpar <- prop$pars\n              pr1 <- pr2\n              oll <- nll\n              accept <<- c(accept,1)\n            } else {\n              accept <<- c(accept,0)\n            }\n            store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n          } else {\n            if(u < ct$bk+ct$tk+ct$ak+ct$sk+ct$pk){\n              prop <- .adjustPos(cache,oldpar,oldmap,D$pk)\n              accept.type <<- c(accept.type,'position')\n              pr2 <- .prior(prop$pars,prop$emap,cache)\n              hr <- prop$hr\n              new <- .emOU.lik(prop$pars,prop$emap,cache,dat,SE=0)\n              nll <- new$loglik\n              if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n                oldpar <- prop$pars\n                oldmap <- prop$emap\n                pr1 <- pr2\n                oll <- nll\n                accept <<- c(accept,1)\n              } else {\n                accept <<- c(accept,0)\n              }\n              store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n            } else {\n              if(u < ct$bk+ct$tk+ct$ak+ct$sk+ct$pk+ct$udk){\n                prop <- .slideBranch(cache,oldpar,oldmap,1)\n                accept.type <<- c(accept.type,\"slideshift\")\n                pr2 <- .prior(prop$pars,prop$emap,cache)\n                hr <- prop$hr\n                new <- .emOU.lik(prop$pars,prop$emap,cache,dat,SE=0)\n                nll <- new$loglik\n                if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n                  oldpar <- prop$pars\n                  oldmap <- prop$emap\n                  pr1 <- pr2\n                  oll <- nll\n                  accept <<- c(accept,1)\n                } else {\n                  accept <<- c(accept,0)\n                }\n                store(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk)\n              }\n            }\n          }\n        }\n      }\n    }\n    ct <<- init.control(oldmap)\n    if(plot){\n      if(i %% plot.freq==0){\n        tr <- emap2simmap(oldmap,cache$phy)\n        oldpar <-oldpar\n        oldmap <-oldmap\n        tcols <- makeTransparent(tr$col,alpha=100)\n        plot(plot.dim[[1]],plot.dim[[2]],type=\"n\",xlab=\"time\",ylab=\"phenotype\")\n        mtext(paste(\"gens = \",i,\" lnL = \",round(oll,2)),3)\n        regime.plot(oldpar,tr,tcols,type=\"density\")\n        phenogram(tr,dat,colors=tr$col,ftype=\"off\",add=TRUE)\n      }\n    }\n    if(i %in% tuning.int){\n      D <- tune.D(D,accept,accept.type)$D\n    }\n    if(i%%ticker.freq==0){\n      tick <- c(i,oll,pr1,log(2)/oldpar$alpha,oldpar$sig2/(2*oldpar$alpha),oldpar$nb,tapply(accept,accept.type,mean))\n      tick[-1] <- round(tick[-1],2)\n      names(tick)[1:6] <- c('gen','lnL','prior','half.life','Vy','K')\n      if(i==ticker.freq){\n        cat(c(names(tick),'\\n'),sep='\\t')\n      }\n      cat(c(tick,'\\n'),sep='\\t')\n    }\n  }\n  closeAllConnections()\n  return(list('dir.name'=dir.name,'dir'=dir,'accept'=accept,'accept.type'=accept.type))\n}\n\noumcmc.loader <- function(dir=NULL,outname=\"bayou\",model=\"OU\"){\n  #mapsr2 <- read.table(file=\"mapsr2.dta\",header=FALSE)\n  #mapsb <- read.table(file=\"mapsb.dta\",header=FALSE)\n  #mapst2 <- read.table(file=\"mapst2.dta\",header=FALSE)\n  mapsr2 <- scan(file=paste(dir,outname,\".mapsr2\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  mapsb <- scan(file=paste(dir,outname,\".mapsb\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  mapst2 <- scan(file=paste(dir,outname,\".mapst2\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  pars.out <- scan(file=paste(dir,outname,\".pars\",sep=\"\"),what=\"\",sep=\"\\n\",quiet=TRUE,blank.lines.skip=FALSE)\n  pars.out <- lapply(strsplit(pars.out,\"[[:space:]]+\"),as.numeric)\n  mapsr2 <- lapply(strsplit(mapsr2,\"[[:space:]]+\"),as.numeric)\n  mapsb <- lapply(strsplit(mapsb,\"[[:space:]]+\"),as.numeric)\n  mapst2 <- lapply(strsplit(mapst2,\"[[:space:]]+\"),as.numeric)\n  chain <- list()\n  if(model==\"OU\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$alpha <- sapply(pars.out,function(x) x[4])\n    chain$sig2 <- sapply(pars.out,function(x) x[5])\n    chain$nb <- sapply(pars.out,function(x) x[6])\n    chain$ntheta <- sapply(pars.out,function(x) x[7])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:7)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  if(model==\"QG\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$h2 <- sapply(pars.out,function(x) x[4])\n    chain$P <- sapply(pars.out,function(x) x[5])\n    chain$w2 <- sapply(pars.out,function(x) x[6])\n    chain$Ne <- sapply(pars.out,function(x) x[7])\n    chain$nb <- sapply(pars.out,function(x) x[8])\n    chain$ntheta <- sapply(pars.out,function(x) x[9])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:9)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  if(model==\"OUrepar\"){\n    chain$gen <- sapply(pars.out,function(x) x[1])\n    chain$lnL <- sapply(pars.out,function(x) x[2])\n    chain$prior <- sapply(pars.out,function(x) x[3])\n    chain$halflife <- sapply(pars.out,function(x) x[4])\n    chain$Vy <- sapply(pars.out,function(x) x[5])\n    chain$nb <- sapply(pars.out,function(x) x[6])\n    chain$ntheta <- sapply(pars.out,function(x) x[7])\n    chain$optima <- lapply(pars.out,function(x) x[-(1:7)])\n    chain$branch.shift <- mapsb\n    chain$location <- mapsr2\n    chain$t2 <- mapst2\n  }\n  return(chain)\n}\n\n\n##Modified from Liam Revell's plotSimmap function\nplotSimmap.mcmc <- function (tree,chain,burnin=NULL,colors = NULL, fsize = 1, ftype = \"reg\", lwd = 2, \n                             pts = TRUE, node.numbers = FALSE, mar = NULL, add = FALSE, \n                             offset = NULL,alpha=10,sh.cex=1,type=\"dashes\",circle.col=NULL,pch=21) {\n  tree <- reorder.phylo(tree,order=\"postorder\")\n  if(type==\"circles\"){\n    L <- Lposterior(list(chain),burnin=burnin,tree)\n  }\n  if (is.null(tree$maps)){\n    tree$maps <- lapply(tree$edge.length,function(x){names(x) <- 1; x})\n    } \n  nb <- length(unique(unlist(sapply(tree$maps,names))))\n  if (class(tree) == \"multiPhylo\") {\n    par(ask = TRUE)\n    for (i in 1:length(tree)) plotSimmap(tree[[i]], colors = colors, \n                                         fsize = fsize, ftype = ftype, lwd = lwd, pts = pts, \n                                         node.numbers = node.numbers)\n  } else {\n    \n    ftype <- which(c(\"off\", \"reg\", \"b\", \"i\", \"bi\") == ftype) - 1\n    if (!ftype) \n      fsize = 0\n    if (is.null(colors)) {\n      colors <- rainbow(nb-1)\n      colors <- c(\"gray50\",colors)\n      names(colors) <- as.character(1:nb)\n    }\n    if (class(tree) != \"phylo\") \n      stop(\"tree should be object of class 'phylo.'\")\n    tree$tip.label <- gsub(\"_\", \" \", tree$tip.label)\n    cw <- reorderSimmap(tree)\n    o <- phytools:::whichorder(cw$edge[,2],tree$edge[,2])\n    ob <- (1:length(tree$edge.length))[o]\n                                        #shifts.o <- shifts[o,]\n    pw <- reorderSimmap(tree, \"pruningwise\")\n    n <- length(cw$tip)\n    m <- cw$Nnode\n    Y <- matrix(NA, m + n, 1)\n    Y[cw$edge[cw$edge[, 2] <= length(cw$tip), 2]] <- 1:n\n    nodes <- unique(pw$edge[, 1])\n    for (i in 1:m) {\n      desc <- pw$edge[which(pw$edge[, 1] == nodes[i]), \n                      2]\n      Y[nodes[i]] <- (min(Y[desc]) + max(Y[desc]))/2\n    }\n    root <- length(cw$tip) + 1\n    node.height <- matrix(NA, nrow(cw$edge), 2)\n    for (i in 1:nrow(cw$edge)) {\n      if (cw$edge[i, 1] == root) {\n        node.height[i, 1] <- 0\n        node.height[i, 2] <- cw$edge.length[i]\n      }\n      else {\n        node.height[i, 1] <- node.height[match(cw$edge[i, \n                                                       1], cw$edge[, 2]), 2]\n        node.height[i, 2] <- node.height[i, 1] + cw$edge.length[i]\n      }\n    }\n                                        #shifts.o <- node.height[,1]+shifts.o\n    postburn <- round(burnin*length(chain$branch.shift),0):length(chain$branch.shift)\n    b.shift <- unlist(chain$branch.shift[postburn])\n    r1 <- tree$edge.length[b.shift]-unlist(chain$location[postburn])\n    loc.shift <- r1\n    shifts.o <- node.height[match(b.shift,o),1]+loc.shift\n    L <- L[o,]\n    if (is.null(mar)) {\n      par(mar = c(0.1, 0.1, 0.1, 0.1))\n    } else par(mar = mar)\n    if (!add) \n      plot.new()\n    if (fsize * max(strwidth(cw$tip.label)) < 1) {\n      c <- (1 - fsize * max(strwidth(cw$tip.label)))/max(node.height)\n      cw$edge.length <- c * cw$edge.length\n      cw$maps <- lapply(cw$maps, function(x) x <- c * x)\n      node.height <- c * node.height\n    } else message(\"Font size too large to properly rescale tree to window.\")\n    height <- max(nodeHeights(tree))\n    if (!add) \n      plot.window(xlim = c(0, max(node.height) + fsize * \n                    max(strwidth(cw$tip.label))), ylim = c(1, max(Y)))\n    for (i in 1:m) lines(node.height[which(cw$edge[, 1] == \n                                           nodes[i]), 1], Y[cw$edge[which(cw$edge[, 1] == nodes[i]), \n                                                                    2]], col = colors[names(cw$maps[[match(nodes[i], \n                                                                           cw$edge[, 1])]])[1]], lwd = lwd)\n    for (i in 1:nrow(cw$edge)) {\n      x <- node.height[i, 1]\n                                        #  bs <- shifts.o/height\n                                        # points(bs,rep(Y[cw$edge[i,2]],length(bs)),cex=sh.cex,pch=\"|\",lwd=(lwd-1),col=makeTransparent(\"#000000\",alpha=alpha))\n      for (j in 1:length(cw$maps[[i]])) {\n        lines(c(x, x + cw$maps[[i]][j]), c(Y[cw$edge[i, \n                                                     2]], Y[cw$edge[i, 2]]), col = colors[names(cw$maps[[i]])[j]], \n              lwd = lwd, lend = 2)\n        if (pts)\n          points(c(x, x + cw$maps[[i]][j]), c(Y[cw$edge[i, \n                                                        2]], Y[cw$edge[i, 2]]), pch = 20, lwd = (lwd - \n                                                                                  1))\n        x <- x + cw$maps[[i]][j]\n        j <- j + 1\n      }\n    }\n\n    if(type==\"dashes\"){\n      bs <- shifts.o*c\n      points(bs,Y[tree$edge[b.shift,2]],cex=sh.cex,pch=\"|\",lwd=(lwd-1),col=makeTransparent(\"#000000\",alpha=alpha))\n    }\n    if(type==\"circles\"){\n      if(is.null(circle.col)){circle.col=\"#000000\"} else {circle.col=circle.col[o]}\n      points(node.height[,1], Y[cw$edge[, 2]],cex=L[,1]*5,lwd=1.2,bg=makeTransparent(circle.col,alpha=alpha),pch=pch)\n    }\n    \n    if (node.numbers) {\n      symbols(0, mean(Y[cw$edge[cw$edge[, 1] == (length(cw$tip) + \n                                                 1), 2]]), rectangles = matrix(c(1.2 * fsize * \n                                                             strwidth(as.character(length(cw$tip) + 1)), 1.4 * \n                                                             fsize * strheight(as.character(length(cw$tip) + \n                                                                                            1))), 1, 2), inches = F, bg = \"white\", add = T)\n      text(0, mean(Y[cw$edge[cw$edge[, 1] == (length(cw$tip) + \n                                              1), 2]]), length(cw$tip) + 1, cex = fsize)\n      for (i in 1:nrow(cw$edge)) {\n        x <- node.height[i, 2]\n        if (cw$edge[i, 2] > length(tree$tip)) {\n          symbols(x, Y[cw$edge[i, 2]], rectangles = matrix(c(1.2 * \n                                         fsize * strwidth(as.character(cw$edge[i, \n                                                                               2])), 1.4 * fsize * strheight(as.character(cw$edge[i, \n                                                                                                                                  2]))), 1, 2), inches = F, bg = \"white\", add = T)\n          text(x, Y[cw$edge[i, 2]], cw$edge[i, 2], cex = fsize)\n        }\n      }\n    }\n        if (is.null(offset)) \n          offset <- 0.2 * lwd/3 + 0.2/3\n    for (i in 1:n) if (ftype) \n      text(node.height[which(cw$edge[, 2] == i), 2], Y[i], \n           cw$tip.label[i], pos = 4, offset = offset, cex = fsize, \n           font = ftype)\n  }\n  par(mar = c(5, 4, 4, 2) + 0.1)\n}\n\n\n\ngelman.R <- function(parameter,chain1,chain2,freq=20,start=1,plot=TRUE){\n  R <- NULL\n  R.UCI <- NULL\n  int <- seq(start,length(chain1[[parameter]]),freq)\n  for(i in 1:length(int)){\n    chain.list <- mcmc.list(mcmc(chain1[[parameter]][1:int[i]]),mcmc(chain2[[parameter]][1:int[i]]))\n    GD <- gelman.diag(chain.list)\n    R[i] <- GD$psrf[1]\n    R.UCI[i] <- GD$psrf[2]\n  }\n  if(plot==TRUE){\n    plot(chain1$gen[int],R,ylim=c(0.9,1.8),main=paste(\"Gelman's R:\",parameter),xlab=\"Generation\",ylab=\"R\",lwd=2)\n    lines(chain1$gen[int],R,lwd=2)\n    lines(chain1$gen[int],R.UCI,lty=2)\n  }\n  return(data.frame(\"R\"=R,\"UCI.95\"=R.UCI))\n}\nposterior.Q <- function(parameter,chain1,chain2,pars=simpar$pars,burnin=0.3){\n  postburn <- round(burnin*length(chain1$gen),0):length(chain1$gen)\n  chain <- mcmc.list(mcmc(chain1[[parameter]][postburn]),mcmc(chain2[[parameter]][postburn]))\n  posterior.q <- summary(chain,quantiles=seq(0,1,0.005))$quantiles\n  q <- which(names(sort(c(pars[[parameter]],posterior.q)))==\"\")\n  Q <- ((q-1)/2-0.25)/100#((q-1)+(simpar$pars$alpha-posterior.q[q-1])/(posterior.q[q+1]-posterior.q[q-1]))/100\n  Q\n}\n\nLposterior <- function(chain.list,phy,simpar=NULL,burnin=0.3,mag=TRUE){\n  ntips <- length(phy$tip.label)\n  shifts=list()\n  branch.shifts=list()\n  optima <- list()\n  postburn <- round(burnin*length(chain.list[[1]]$gen),0):length(chain.list[[1]]$gen)\n  for(i in 1:length(chain.list)){\n    shifts[[i]] <- t(sapply(chain.list[[i]]$branch.shift[postburn],function(x) as.numeric(1:nrow(phy$edge) %in% x)))\n    optima[[i]] <- sapply(1:length(chain.list[[i]]$optima),function(x) chain.list[[i]]$optima[[x]][chain.list[[i]]$t2[[x]]])\n    branch.shifts[[i]] <- chain.list[[i]]$branch.shift\n  }\n  optima.shifts <- tapply(unlist(optima),unlist(branch.shifts),mean)\n  N.optima.shifts <- tapply(unlist(branch.shifts),unlist(branch.shifts),length)\n  root.optima <- sapply(chain.list,function(x) sapply(x$optima,function(y) y[1]))\n  OS <- rep(mean(root.optima),length(phy$edge[,1]))\n  OS[as.numeric(names(optima.shifts))] <- optima.shifts\n  shifts.tot <- sapply(shifts,function(x) apply(x,2,sum))\n  shifts.prop <- shifts.tot/length(postburn)\n  if (!is.null(simpar)){\n    bshift <- subset(simpar$edge.map,simpar$edge.map$sh==1)\n    shift.mag <- simpar$pars$optima[bshift$t2]-simpar$pars$optima[bshift$t1]\n    all.branches <- rep(0,nrow(simpar$edge.map))\n    all.branches[as.numeric(rownames(bshift))] <- shift.mag\n    shift.age <- (nodeHeights(simpar$tree)[,1]+simpar$edge.map$r1)\n    prior.prob <- sum(sapply(1:(ntips/2),function(x) kFUN(x,log=FALSE)*sum(1/(length(all.branches):(length(all.branches)-(x-1))))))\n    Lpost <- data.frame(shifts.prop,\"prior\"=prior.prob,\"pp2prior\"=apply(shifts.prop,1,mean)/prior.prob,\"sh\"=simpar$edge.map$sh,\"shift.mag\"=all.branches,\"shift.age\"=shift.age)\n  } else {\n    all.branches <- rep(0,nrow(phy$edge))\n    prior.prob <- sum(sapply(1:(ntips/2),function(x) kFUN(x,log=FALSE)*sum(1/(length(all.branches):(length(all.branches)-(x-1))))))\n    Lpost <- data.frame(shifts.prop,\"prior\"=prior.prob,\"pp2prior\"=apply(shifts.prop,1,mean)/prior.prob,mag=OS)\n  }\n  return(Lpost)\n}\n\n\n.emap.sim <- function(tree,locs,div.mean,div.sd,model=\"additive\"){\n  nHs <- nodeHeights(tree)\n  K <- length(locs)\n  br <- NULL\n  for (i in 1:length(locs)){\n    prob <- apply(nHs,1,function(x) locs[i]>x[1] & locs[i]<x[2])\n    prob[br] <- FALSE\n    ind <- sample(1:length(tree$edge.length),1,prob=as.numeric(prob))\n    br <- c(br,ind)\n  }\n  br.r1 <- locs-nHs[br,1]\n  br.r2 <- nHs[br,2]-locs\n  shifts <- rep(0,length(tree$edge.length))\n  shifts[br] <- 1\n  nopt <- rep(1,length(shifts)+1)\n  Th <- rep(0,K+1)\n  opt <- 1\n  for(i in length(shifts):1){\n    if(shifts[i]==1){\n      opt <- opt+1\n      nopt[tree$edge[i,2]] <- opt\n      if(model==\"additive\"){\n        Th[opt] <- Th[nopt[tree$edge[i,1]]]+sample(c(-1,1),1)*rnorm(1,div.mean,div.sd)\n      }\n      if(model==\"HOC\"){\n        Th[opt] <- rnorm(1,div.mean,div.sd)\n      }\n    } else {\n      nopt[tree$edge[i,2]] <- nopt[tree$edge[i,1]]\n    }\n  }\n  r1 <- tree$edge.length\n  r2 <- rep(0,length(tree$edge.length))\n  r1[br] <- br.r1\n  r2[br] <- br.r2\n  edge.map <- data.frame(tree$edge,nopt[tree$edge[,1]],nopt[tree$edge[,2]],shifts,tree$tip.label[tree$edge[,2]],r1,r2,tree$edge.length)\n  colnames(edge.map)= c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(list(\"emap\"=edge.map,\"optima\"=Th))\n}\n\n# function creates a phenogram\n# written by Liam J. Revell 2011, 2012\n\nphenogram<-function(tree,x,fsize=1.0,ftype=\"reg\",colors=NULL,axes=list(),add=FALSE,fcols=NULL,xadj=0){\n\t# check tree\n\tif(class(tree)!=\"phylo\") stop(\"tree should be an object of class 'phylo'\")\n\t# check font\n\tftype<-which(c(\"off\",\"reg\",\"b\",\"i\",\"bi\")==ftype)-1\n        if(is.null(fcols)){\n          fcols=rep(1,length(tree$tip.label))\n          names(fcols) <- tree$tip.label\n        }\n\tif(!ftype) fsize=0 \n\tH<-nodeHeights(tree)\n\tif(length(x)<(length(tree$tip)+tree$Nnode))\n\t\tx<-c(x,fastAnc(tree,x))\n\telse\n\t\tx<-c(x[tree$tip.label],x[as.character(length(tree$tip)+1:tree$Nnode)])\n\tx[1:length(tree$tip)]<-x[tree$tip.label]\n\tnames(x)[1:length(tree$tip)]<-1:length(tree$tip)\n\tX<-matrix(x[as.character(tree$edge)],nrow(tree$edge),ncol(tree$edge))\n\tif(!add) plot.new()\n\tif(is.null(axes$trait)) ylim<-c(min(x),max(x))\n\telse ylim<-axes$trait\n\tif(is.null(axes$time)) xlim<-c(min(H),max(H)+fsize*max(strwidth(tree$tip.label)))\n\telse xlim<-c(axes$time[1],axes$time[2]+fsize*max(strwidth(tree$tip.label)))\n\tif(!add) plot.window(ylim=ylim,xlim=xlim)\n\tif(is.null(tree$maps)){\n\t\tfor(i in 1:nrow(H)){ \n\t\t\tlines(H[i,],X[i,])\n\t\t\tif(tree$edge[i,2]<=length(tree$tip))\n\t\t\t\tif(fsize) text(tree$tip.label[tree$edge[i,2]],x=H[i,2]+0.02*max(H),y=X[i,2],cex=fsize,font=ftype,col=fcols[tree$tip.label[tree$edge[i,2]]])\n\t\t}\n\t} else {\n\t\tif(is.null(colors)){ \n\t\t\tcolors<-palette()\n\t\t\tnames(colors)<-as.character(1:8)\n\t\t}\n\t\tfor(i in 1:nrow(H)){\n\t\t\ty<-H[i,1]\n\t\t\tm<-diff(X[i,])/diff(H[i,])\n\t\t\tfor(j in 1:length(tree$maps[[i]])){\n\t\t\t\ta<-c(y,y+tree$maps[[i]][j])\n\t\t\t\tb<-m*(a-H[i,1])+X[i,1]\n\t\t\t\tlines(a,b,col=colors[names(tree$maps[[i]])[j]],lwd=2)\n\t\t\t\ty<-a[2]\n\t\t\t}\n\t\t\tif(tree$edge[i,2]<=length(tree$tip))\n\t\t\t\tif(fsize) text(tree$tip.label[tree$edge[i,2]],x=H[i,2]+0.02*max(H)+xadj,y=X[i,2],cex=fsize,font=ftype,col=fcols[tree$tip.label[tree$edge[i,2]]])\n\t\t}\n\t}\n\tif(!add){ \n\t\taxis(1); axis(2); title(xlab=\"time\",ylab=\"phenotype\")\n\t}\n}\n\n\ndiscard.burnin <- function(chain,burnin.prop=0.3){\n  lapply(chain,function(x) x[(burnin.prop*length(x)):length(x)])\n}\n\nbuild.control <- function(pars,emap,default.weights=\"OU\",move.weights=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"nb\"=10)){\n  if(!is.null(default.weights)){\n    if(default.weights==\"OU\"){\n      move.weights=list(\"alpha\"=4,\"sig2\"=2,\"optima\"=4,\"pos\"=1,\"slide\"=2,\"nb\"=10)\n    }\n    if(default.weights==\"QG\"){\n      move.weights=list(\"h2\"=5,\"P\"=2,\"w2\"=5,\"Ne\"=5,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"nb\"=20)\n    }\n    if(default.weights==\"OUrepar\"){\n      move.weights=list(\"halflife\"=5,\"Vy\"=3,\"optima\"=5,\"pos\"=1,\"slide\"=3,\"nb\"=20)\n    }\n  }\n  ct <- as.list(rep(NA,length(pars)+1))\n  names(ct) <- c(names(pars),'pos')\n  names(ct)[names(ct)==\"ntheta\"] <- \"slide\"\n  total.weight <- sum(unlist(move.weights))\n  move.weights <- unlist(move.weights[names(ct)])\n  ct$nb <- unname(move.weights['nb']/total.weight)\n  R <-1-ct$nb\n  if (sum(emap$sh)== 0){\n    ct$pos <- 0\n    ct$slide <- 0\n    n.na <- sapply(ct,is.na)\n    ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n  } else {\n    if (sum(1-emap$sh)==0){\n      ct$slide <- 0\n      n.na <- sapply(ct,is.na)\n      ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n    } else {\n      n.na <- sapply(ct,is.na)\n      ct[n.na] <- move.weights[n.na]/sum(move.weights[n.na])*R\n    }\n  }\n  return(ct)\n}\n\ntune.D <- function(D,accept,accept.type){\n  tuning.samp <- (length(accept)/2):length(accept)\n  acc <- tapply(accept[tuning.samp],accept.type[tuning.samp],mean)\n  acc.length <- tapply(accept[tuning.samp],accept.type[tuning.samp],length)\n  acc.tune <- acc/0.25\n  acc.tune[acc.tune<0.5] <- 0.5\n  acc.tune[acc.tune>2] <- 2\n  D$ak <- acc.tune['alpha']*D$ak\n  D$sk <- acc.tune['sig2']*D$sk\n  D$tk <- acc.tune['theta']*D$tk\n  D$bk <- D$tk*2\n  D <- lapply(D,function(x){ names(x) <- NULL; x})\n  return(list(\"D\"=D,\"acc.tune\"=acc.tune))\n}\n\n\nstore.QG <- function(i,pars,maps,cache,dat,ll,pr,samp,chunk,parorder){\n  if(i%%samp==0){\n    j <- (i/samp)%%chunk\n    if(j!=0 & i>0){\n      chunk.branch[[j]] <<- (1:length(maps$sh))[maps$sh==1]\n      chunk.t2[[j]] <<- maps$t2[maps$sh==1]\n      chunk.r2[[j]] <<- maps$r2[maps$sh==1]\n      parline <- unlist(pars[parorder])\n      out[[j]] <<- c(i,ll,pr,parline)\n    } else {\n                                        #chunk.mapst1[chunk,] <<- maps$t1\n                                        #chunk.mapst2[chunk,] <<- maps$t2\n                                        #chunk.mapsr2[chunk,] <<- maps$r2\n      chunk.branch[[chunk]] <<- (1:length(maps$sh))[maps$sh==1]\n      chunk.t2[[chunk]] <<- maps$t2[maps$sh==1]\n      chunk.r2[[chunk]] <<- maps$r2[maps$sh==1]\n      parline <- unlist(pars[parorder])\n      out[[chunk]] <<- c(i,ll,pr,parline)\n                                        #write.table(chunk.mapst1,file=mapst1,append=TRUE,col.names=FALSE,row.names=FALSE)\n                                        #write.table(chunk.mapst2,file=mapst2,append=TRUE,col.names=FALSE,row.names=FALSE)\n                                        #write.table(chunk.mapsr2,file=mapsr2,append=TRUE,col.names=FALSE,row.names=FALSE)\n      lapply(out,function(x) cat(c(x,\"\\n\"),file=pars.output,append=TRUE))\n      lapply(chunk.branch,function(x) cat(c(x,\"\\n\"),file=mapsb,append=TRUE))\n      lapply(chunk.t2,function(x) cat(c(x,\"\\n\"),file=mapst2,append=TRUE))\n      lapply(chunk.r2,function(x) cat(c(x,\"\\n\"),file=mapsr2,append=TRUE))\n                                        #chunk.mapst1 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n                                        #chunk.mapst2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n                                        #chunk.mapsr2 <<- matrix(0,ncol=dim(oldmap)[1],nrow=chunk)\n                                        #out <<- list()\n      chunk.branch <<- list()\n      chunk.r2 <<- list()\n      chunk.t2 <<- list()\n      out <<- list()\n    }\n  }\n}\n\n#tree <- cache$phy\n#dat <- cache$dat\n#SE=0.1\n#model=\"OU\"\n#ngen=10000\n#samp=20\n#chunk=100\n#control=NULL\n#tuning=NULL#list(halflife=1,Vy=1,nb=1,optima=0.5,slide=1,pos=mean(cache$edge.length))\n#new.dir=FALSE\n#plot=TRUE\n#plot.freq=500\n#outname=\"sweave1\"\n#ticker.freq=1000\n#tuning.int=c(0.1,0.2,0.3)\n#moves=NULL\n#control.weights=NULL\n\n\nrjmcmc.QG <- function(tree,dat,SE=0,model=\"OU\",ngen=100000,samp=10,chunk=100,control=NULL,tuning=NULL,new.dir=FALSE,plot=TRUE,plot.freq=500,outname=\"bayou\",ticker.freq=1000,tuning.int=c(0.1,0.2,0.3),startpar=NULL,moves=NULL,control.weights=NULL){\n  if(is.null(moves)){\n    moves <- switch(model,\"QG\"=list(h2=\".multiplierProposal\",P=\".multiplierProposal\",w2=\".multiplierProposal\",Ne=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"),\"OU\"=list(alpha=\".multiplierProposal\",sig2=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"),\"OUrepar\"=list(halflife=\".multiplierProposal\",Vy=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"))\n  }\n  cache <- .prepare.ou.univariate(tree,dat)\n                                        #FOR NOW PROVIDE STARTPAR\n                                        #  if(is.null(startpar)){\n                                        #    startpar <- .priorsim(.prior,tree,plot=FALSE)\n                                        #  }\n  if(is.null(control.weights)){\n    ct <- build.control(startpar$pars,startpar$emap,default.weights=model)\n  } else {ct <- build.control(startpar$pars,startpar$emap,default.weights=NULL,move.weights=control.weights)}\n\n  if(is.null(tuning)){\n    D <- switch(model, \"OU\"=list(alpha=1, sig2= 1, nb = 4,optima=2,slide=1,pos=mean(cache$edge.length)), \"QG\"=list(h2=1,P=1,w2=1,Ne=1, nb = 4,optima=2,slide=1,pos=mean(cache$edge.length)),\"OUrepar\"=list(halflife=1,Vy=1,nb=4,optima=2,slide=1,pos=mean(cache$edge.length)))\n  } else { D <- tuning}\n\n  if(attributes(.prior)$distributions$bprior==\"equal\"){\n    plim <- 0\n  } else {plim <- cache$ntips}\n\n  if(new.dir){\n    dir.name <- paste(sample(LETTERS,10),collapse=\"\")\n    dir <- paste(getwd(),\"/\",dir.name,\"/\",sep=\"\")\n    dir.create(dir)\n    setwd(dir)\n  } else {\n    dir <- getwd()\n    dir.name <- sapply(strsplit(dir,'/'),function(x) x[length(x)])\n    }\n\n  mapsb <<- file(paste(outname,\".mapsb\",sep=\"\"),open=\"w\")\n  mapsr2 <<- file(paste(outname,\".mapsr2\",sep=\"\"),open=\"w\")\n  mapst2 <<- file(paste(outname,\".mapst2\",sep=\"\"),open=\"w\")\n  pars.output <<- file(paste(outname,\".pars\",sep=\"\"),open=\"w\")\n\n  oldpar <- startpar$pars\n  oldmap <- startpar$emap\n  chunk.branch <<- list()\n  chunk.r2 <<- list()\n  chunk.t2 <<- list()\n  out <<- list()\n\n  oll  <- .emOU.lik(oldpar,oldmap,cache,dat,SE=SE,model=model)$loglik\n  pr1 <- .prior(oldpar,oldmap,cache)\n  parorder <- switch(model,\"QG\"=c(\"h2\",\"P\",\"w2\",\"Ne\",\"nb\",\"ntheta\",\"optima\"), \"OU\"=c(\"alpha\",\"sig2\",\"nb\",\"ntheta\",\"optima\"),\"OUrepar\"=c(\"halflife\",\"Vy\",\"nb\",\"ntheta\",\"optima\"))\n\n  accept.type <- NULL\n  accept <- NULL\n\n  tr <- emap2simmap(oldmap,cache$phy)\n  tcols <- makeTransparent(tr$col,alpha=100)\n  if(plot){\n    phenogram(tr,dat,colors=tr$col,ftype=\"off\")\n    plot.dim <- list(par('usr')[1:2],par('usr')[3:4])\n  }\n  #tuning.int <- round(tuning.int*ngen,0)\n  for (i in 1:ngen){\n    u <- runif(1)\n    prop <- .proposalFn(u,ct,D,moves,cache,oldpar,oldmap)\n    new.pars <- prop$prop$pars\n    new.emap <- prop$prop$emap\n    accept.type <- c(accept.type,paste(prop$prop$decision,prop$move,sep=\".\"))\n    pr2 <- .prior(new.pars,new.emap,cache)\n    hr <- prop$prop$hr\n    new <- .emOU.lik(new.pars,new.emap,cache,dat,SE=SE,model=model)\n    nll <- new$loglik\n    if (runif(1) < exp(nll-oll+pr2-pr1+hr)){\n      oldmap <- new.emap\n      oldpar <- new.pars\n      pr1 <- pr2\n      oll <- nll\n      accept <- c(accept,1)\n    } else {\n      accept <- c(accept,0)\n    }\n    store.QG(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk,parorder)\n    if(ct$nb+ct$slide > 0){\n      ct <- build.control(oldpar,oldmap,default.weights=model)\n    }\n    if(plot){\n      if(i %% plot.freq==0){\n        tr <- emap2simmap(oldmap,cache$phy)\n        tcols <- makeTransparent(tr$col,alpha=100)\n        plot(plot.dim[[1]],plot.dim[[2]],type=\"n\",xlab=\"time\",ylab=\"phenotype\")\n        mtext(paste(\"gens = \",i,\" lnL = \",round(oll,2)),3)\n        try(regime.plot(oldpar,tr,tcols,type=\"density\",model=model),silent=TRUE)\n        phenogram(tr,dat,colors=tr$col,ftype=\"off\",add=TRUE)\n      }\n    }\n    #if(i %in% tuning.int){\n    #  D <- tune.D(D,accept,accept.type)$D\n    #}\n    if(i%%ticker.freq==0){\n      alpha <- switch(model,\"QG\"=QG.alpha(oldpar),\"OU\"=oldpar$alpha,\"OUrepar\"=OU.repar(oldpar)$alpha)\n      sig2 <- switch(model,\"QG\"=QG.sig2(oldpar),\"OU\"=oldpar$sig2,\"OUrepar\"=OU.repar(oldpar)$sig2)\n      tick <- c(i,oll,pr1,log(2)/alpha,sig2/(2*alpha),oldpar$nb,tapply(accept,accept.type,mean))\n      tick[-1] <- round(tick[-1],2)\n      names(tick)[1:6] <- c('gen','lnL','prior','half.life','Vy','K')\n      if(i==ticker.freq){\n        cat(c(names(tick),'\\n'),sep='\\t')\n      }\n      cat(c(tick,'\\n'),sep='\\t')\n    }\n  }\n  closeAllConnections()\n  return(list('dir.name'=dir.name,'dir'=dir,'accept'=accept,'accept.type'=accept.type))\n}\n\n\n.proposalFn <- function(u,ct,D,moves,cache,oldpar,oldmap){\n  move <- names(ct)[u < cumsum(unlist(ct))][1]\n  .moveFn <- get(moves[[move]])\n  prop <- .moveFn(move=move,emap=oldmap,pars=oldpar,cache=cache,d=D[[move]])\n  return(list(prop=prop,move=move,u=u))\n}\n\n###Stepping stone modeling\nmake.refFn <- function(chain,.prior,model=\"OU\",burnin=0.3){\n  parorder <- switch(model,\"QG\"=c(\"h2\",\"P\",\"w2\",\"Ne\",\"nb\",\"ntheta\",\"optima\"), \"OU\"=c(\"alpha\",\"sig2\",\"nb\",\"ntheta\",\"optima\"),\"OUrepar\"=c(\"halflife\",\"Vy\",\"nb\",\"ntheta\",\"optima\"))\n  postburn <- round(0.3*length(chain[[1]]),0):length(chain[[1]])\n  fx <- lapply(attributes(.prior)$distributions,function(x) try(get(x),silent=TRUE))\n  fx$bprior <- bFUN\n  dists <- attributes(.prior)$distributions\n  switch.dist <- function(distribution) {try(switch(distribution,\"dbeta\"=\"beta\", \"dcauchy\"=\"cauchy\", \"dchisq\"=\"chi-squared\",\"dexp\"=\"exponential\", \"dgamma\"=\"gamma\",\"dlnorm\"=\"lognormal\",\"dnorm\"=\"normal\",\"dpois\"=\"Poisson\", \"cdpois\"=\"Poisson\"),silent=TRUE)}\n  dist.names <- lapply(dists,switch.dist)\n  names(dist.names) <- sapply(names(dist.names),function(x) try(switch(x,\"dalpha\"=\"alpha\",\"dsig2\"=\"sig2\",\"dk\"=\"nb\",\"dnb\"=\"nb\",\"dtheta\"=\"optima\",\"dh2\"=\"h2\",\"dNe\"=\"Ne\",\"dw2\"=\"w2\",\"dP\"=\"P\",\"dVy\"=\"Vy\",\"dhalflife\"=\"halflife\"), silent=TRUE))\n  tofit <- which(sapply(dist.names,function(x) !is.null(x))==TRUE)\n  start <- attributes(.prior)$parameters[tofit]\n  start <- lapply(tofit,function(y) if(dist.names[y] %in% c(\"lognormal\",\"Poisson\",\"normal\",\"exponential\",\"geometric\")){NULL} else {start[[y]]})\n  fits <- lapply(tofit, function(y) fitdistr(unlist(chain[[names(tofit)[y]]][postburn]),densfun=dist.names[[y]],start=start[[y]])$estimate)\n  fits$nb <- c(fits$nb,\"kmax\"=attributes(.prior)$parameters$nb$kmax)\n  setfx <- lapply(tofit,function(y) set.defaults(fx[[y]],defaults=as.list(fits[[y]])))\n  setfx <- lapply(tofit,function(y) set.defaults(setfx[[y]],log=TRUE))\n  return(function(pars,emap,cache) { dens <- sapply(names(setfx),function(y) sum(setfx[[y]](pars[[y]])));\n                                     bdens <- log(1/choose(2*cache$ntips-2,pars$nb));\n                                     ldens <- sum(dunif(emap$sh[emap$sh==1],log=TRUE));\n                                     return(sum(dens)+bdens+ldens)\n                        })\n}\n\n#make.refFn(chain1,.prior,model=\"OU\",burnin=0.3)->refFn1\n#refFn1(pars,emap,cache)\n#.prior(pars,emap,cache)+\n#.emOU.lik(pars,emap,cache,dat,SE=0,model=\"OU\")$loglik\nmake.powerPosterior <- function(k,Bk,prior.fn,ref.fn){\n  foo <- function(k,Bk,pars,emap,cache,dat,SE,model){\n    lik <- .emOU.lik(pars,emap,cache,cache$dat,SE=SE,model=model)$loglik\n    prior <- prior.fn(pars,emap,cache)\n    ref <- ref.fn(pars,emap,cache)\n    coeff <- c(Bk[k],Bk[k],(1-Bk[k]))\n    result <- c(lik,prior,ref)\n    result[coeff==0] <- 0\n    result <- result*coeff\n    result <- sum(result)\n    return(list(result=result,lik=lik,prior=prior,ref=ref))\n  }\n  return(foo)\n}\n#powerPosterior <- make.powerPosterior(1,Bk,.prior,refFn1)\n#powerPosterior(101,Bk,pars,emap,cache,dat,SE=0,model=\"OU\")\n\n\n\n\n#control=NULL\n#tuning=NULL\n#new.dir=FALSE\n#plot=TRUE\n#plot.freq=500\n#outname=\"bayou.ss\"\n#ticker.freq=1000\n#tuning.int=c(0.1,0.2,0.3)\n#startpar=startpar\n#moves=NULL\n#control.weights=NULL\n#model=\"OU\"\n#ngen=10^5\n#samp=1\n#chunk=1\n#SE=NA\n\n\nsteppingstoneMCMC <- function(tree,dat,powerPosterior,k,Bk,SE=NA,model=\"OU\",ngen=100000,samp=20,chunk=200,control=NULL,tuning=NULL,new.dir=FALSE,plot=TRUE,plot.freq=500,outname=\"bayou.ss\",ticker.freq=1000,tuning.int=c(0.1,0.2,0.3),startpar=NULL,moves=NULL,control.weights=NULL){\n  if(is.null(moves)){\n    moves <- switch(model,\"QG\"=list(h2=\".multiplierProposal\",P=\".multiplierProposal\",w2=\".multiplierProposal\",Ne=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"),\"OU\"=list(alpha=\".multiplierProposal\",sig2=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"),\"OUrepar\"=list(halflife=\".multiplierProposal\",Vy=\".multiplierProposal\",nb=\"splitmerge.emap\",optima=\".adjustTheta\",slide=\".slideBranch\",pos=\".adjustPos\"))\n  }\n  cache <- .prepare.ou.univariate(tree,dat)\n                                        #FOR NOW PROVIDE STARTPAR\n                                        #  if(is.null(startpar)){\n                                        #    startpar <- .priorsim(.prior,tree,plot=FALSE)\n                                        #  }\n  if(is.null(control.weights)){\n    ct <- build.control(startpar$pars,startpar$emap,default.weights=model)\n  } else {ct <- build.control(startpar$pars,startpar$emap,default.weights=NULL,move.weights=control.weights)}\n\n  if(is.null(tuning)){\n    D <- switch(model, \"OU\"=list(alpha=1, sig2= 1, nb = 4,optima=2,slide=1,pos=mean(cache$edge.length)), \"QG\"=list(h2=1,P=1,w2=1,Ne=1, nb = 4,optima=2,slide=1,pos=mean(cache$edge.length)),\"OUrepar\"=list(halflife=1,Vy=1,nb=4,optima=2,slide=1,pos=mean(cache$edge.length)))\n  } else { D <- tuning}\n\n  if(attributes(.prior)$distributions$bprior==\"equal\"){\n    plim <- 0\n  } else {plim <- cache$ntips}\n\n  if(new.dir){\n    dir.name <- paste(sample(LETTERS,10),collapse=\"\")\n    dir <- paste(getwd(),\"/\",dir.name,\"/\",sep=\"\")\n    dir.create(dir)\n    setwd(dir)\n  } else {\n    dir <- getwd()\n    dir.name <- sapply(strsplit(dir,'/'),function(x) x[length(x)])\n    }\n\n  mapsb <<- file(paste(outname,\".\",k,\".mapsb\",sep=\"\"),open=\"w\")\n  mapsr2 <<- file(paste(outname,\".\",k,\".mapsr2\",sep=\"\"),open=\"w\")\n  mapst2 <<- file(paste(outname,\".\",k,\".mapst2\",sep=\"\"),open=\"w\")\n  pars.output <<- file(paste(outname,\".\",k,\".pars\",sep=\"\"),open=\"w\")\n\n  oldpar <- startpar$pars\n  oldmap <- startpar$emap\n  chunk.branch <<- list()\n  chunk.r2 <<- list()\n  chunk.t2 <<- list()\n  out <<- list()\n\n  #oll  <- .emOU.lik(oldpar,oldmap,cache,dat,model=model)$loglik\n  #pr1 <- .prior(oldpar,oldmap,cache)\n  pB.old <- powerPosterior(k,Bk,oldpar,oldmap,cache,dat,SE=0,model=model)\n  parorder <- switch(model,\"QG\"=c(\"h2\",\"P\",\"w2\",\"Ne\",\"nb\",\"ntheta\",\"optima\"), \"OU\"=c(\"alpha\",\"sig2\",\"nb\",\"ntheta\",\"optima\"),\"OUrepar\"=c(\"halflife\",\"Vy\",\"nb\",\"ntheta\",\"optima\"))\n\n  accept.type <- NULL\n  accept <- NULL\n\n  tr <- emap2simmap(oldmap,cache$phy)\n  tcols <- makeTransparent(tr$col,alpha=100)\n  if(plot){\n    phenogram(tr,dat,colors=tr$col,ftype=\"off\")\n    plot.dim <- list(par('usr')[1:2],par('usr')[3:4])\n  }\n  #tuning.int <- round(tuning.int*ngen,0)\n  Ref <- NULL\n  for (i in 1:ngen){\n    u <- runif(1)\n    prop <- .proposalFn(u,ct,D,moves,cache,oldpar,oldmap)\n    new.pars <- prop$prop$pars\n    new.emap <- prop$prop$emap\n    accept.type <- c(accept.type,paste(prop$prop$decision,prop$move,sep=\".\"))\n    #pr2 <- .prior(new.pars,new.emap,cache)\n    hr <- prop$prop$hr\n    #new <- .emOU.lik(new.pars,new.emap,cache,dat,model=model)\n    #nll <- new$loglik\n    pB.new <- powerPosterior(k,Bk,new.pars,new.emap,cache,dat,SE=0,model=model)\n    if (runif(1) < exp(pB.new$result-pB.old$result+Bk[k]*hr)){\n      oldmap <- new.emap\n      oldpar <- new.pars\n      pr1 <- pB.new$prior\n      oll <- pB.new$lik\n      pB.old <- pB.new\n      accept <- c(accept,1)\n      if(i %% samp ==0){\n        Ref <- c(Ref,pB.new$ref)\n    }\n    } else {\n      accept <- c(accept,0)\n      if(i %% samp==0){\n        Ref <- c(Ref,pB.old$ref)\n      }\n    }\n    store.QG(i,oldpar,oldmap,cache,dat,oll,pr1,samp,chunk,parorder)\n    if(ct$nb+ct$slide > 0){\n      ct <- build.control(oldpar,oldmap,default.weights=model)\n    }\n    if(plot){\n      if(i %% plot.freq==0){\n        tr <- emap2simmap(oldmap,cache$phy)\n        tcols <- makeTransparent(tr$col,alpha=100)\n        plot(plot.dim[[1]],plot.dim[[2]],type=\"n\",xlab=\"time\",ylab=\"phenotype\")\n        mtext(paste(\"gens = \",i,\" lnL = \",round(oll,2)),3)\n        try(regime.plot(oldpar,tr,tcols,type=\"density\",model=model),silent=TRUE)\n        phenogram(tr,dat,colors=tr$col,ftype=\"off\",add=TRUE)\n      }\n    }\n    #if(i %in% tuning.int){\n    #  D <- tune.D(D,accept,accept.type)$D\n    #}\n    if(i%%ticker.freq==0){\n      alpha <- switch(model,\"QG\"=QG.alpha(oldpar),\"OU\"=oldpar$alpha,\"OUrepar\"=OU.repar(oldpar)$alpha)\n      sig2 <- switch(model,\"QG\"=QG.sig2(oldpar),\"OU\"=oldpar$sig2,\"OUrepar\"=OU.repar(oldpar)$sig2)\n      tick <- c(i,oll,pr1,log(2)/alpha,sig2/(2*alpha),oldpar$nb,tapply(accept,accept.type,mean))\n      tick[-1] <- round(tick[-1],2)\n      names(tick)[1:6] <- c('gen','lnL','prior','half.life','Vy','K')\n      if(i==ticker.freq){\n        cat(c(names(tick),'\\n'),sep='\\t')\n      }\n      cat(c(tick,'\\n'),sep='\\t')\n    }\n  }\n  closeAllConnections()\n  return(list('dir.name'=dir.name,'dir'=dir,'accept'=accept,'accept.type'=accept.type,\"ref\"=Ref))\n}\n\npull.pars <- function(i,chain,model=\"OU\"){\n  parorder <- switch(model,\"QG\"=c(\"h2\",\"P\",\"w2\",\"Ne\",\"nb\",\"ntheta\",\"optima\"), \"OU\"=c(\"alpha\",\"sig2\",\"nb\",\"ntheta\",\"optima\"),\"OUrepar\"=c(\"halflife\",\"Vy\",\"nb\",\"ntheta\",\"optima\"))\n  pars <- lapply(parorder,function(x) chain[[x]][[i]])\n  names(pars) <- parorder\n  return(pars)\n}\n\npull.rsample <- function(samp,chain,fit,refFn,model=\"OU\"){\n  #pars.list <- lapply(samp,function(y) pull.pars(y,chain,model=model))\n  #emap.list <- lapply(samp,function(y) read.emap(chain$branch.shift[[y]],chain$location[[y]],chain$t2[[y]],cache$phy)$emap)\n  L <- chain$lnL[samp]+chain$prior[samp]-fit$ref[samp]\n  Lmax <- max(L)\n  Lfactored <- L-Lmax\n  return(list(Lmax=Lmax,Lfactored=Lfactored))\n}\n\n#K.chains <- list()\n#ssfits <- list()\n#for (k in 1:length(Bk)){\n#  ssfits[[k]] <- steppingstoneMCMC(tree,dat,powerPosterior,k,Bk,startpar=startpar,ngen=2.5*10^4,samp=10)\n#  K.chains[[k]] <- oumcmc.loader(outname=paste(\"bayou.ss\",\".\",k,sep=\"\"),model=\"OU\")\n#}\n\n#postburn <- seq(round(0.3*length(K.chains[[i]][[1]]),0),length(K.chains[[i]][[1]]),10)\n#lnr <- computelnr(K.chains,Bk,postburn,refFn1,model=\"OU\")\n\ncomputelnr <- function(K.chains,ssfits,Bk,samp,refFn,model=\"OU\"){\n  lnr <- list()\n  for(i in 1:(length(Bk)-1)){\n    Lk <- pull.rsample(samp,K.chains[[i]],ssfits[[i]],refFn,model=model)\n    lnr[[i]] <- (Bk[i+1]-Bk[i])*Lk$Lmax+log(1/length(Lk$Lfactored)*sum(exp(Lk$Lfactored)^(Bk[i+1]-Bk[i])))\n  }\n  return(list(\"lnr\"=sum(unlist(lnr)),\"lnrk\"=lnr))\n} \n\ndiscard.burnin <- function(chain,burnin.prop=0.3){\n  lapply(chain,function(x) x[(burnin.prop*length(x)):length(x)])\n}\ncombine.chains <- function(chain1,chain2,burnin.prop=0){\n  nn <- names(chain1)\n  postburn <- (burnin.prop*(length(chain1$gen))+1):(length(chain1$gen))\n  chains <- lapply(nn,function(x) c(chain1[[x]][postburn],chain2[[x]][postburn]))\n  names(chains) <- nn\n  return(chains)\n}\n\nfilldown.emap <- function(emap){\n  shifts <- emap$sh\n  K <- sum(shifts)\n  nopt <- rep(1,length(shifts)+1)\n  opt <- 1\n  for(i in length(shifts):1){\n    if(shifts[i]==1){\n      opt <- opt+1\n      nopt[emap$e2[i]] <- opt\n    } else {\n      nopt[emap$e2[i]] <- nopt[emap$e1[i]]\n    }\n  }\n  edge.map <- data.frame(tree$edge,nopt[tree$edge[,1]],nopt[tree$edge[,2]],shifts,tree$tip.label[tree$edge[,2]],emap$r1,emap$r2,tree$edge.length)\n  names(edge.map) <- c(\"e1\",\"e2\",\"t1\",\"t2\",\"sh\",\"tip\",\"r1\",\"r2\",\"r\")\n  return(edge.map)\n}\n  \n\nplotSimmap.posterior <- function(chain,i,tree,dat,alpha=255){\n  emap <- read.emap(chain$branch.shift[[i]],chain$location[[i]],chain$t2[[i]],tree)$emap\n  pars <- list(\"alpha\"=chain$alpha[[i]],\"sig2\"=chain$sig2[[i]],nb=chain$nb[[i]],optima=chain$optima[[i]],ntheta=chain$ntheta[[i]])\n  tr <- emap2simmap(emap,tree)\n  phenogram(tr,dat,colors=tr$col,ftype=\"off\")\n  regime.plot2(pars,tr,cols=tr$col,type=\"density\",alpha=100)\n  phenogram(tr,dat,colors=tr$col,add=TRUE,ftype=\"off\") \n}\n\nregime.plot2 <- function(pars,tree,cols,type='rect',alpha=255){\n    OA <- optima.ages(pars,tree)\n    CIU95 <- pars$optima+2*sqrt(pars$sig2/(2*pars$alpha))\n    CIL95 <- pars$optima-2*sqrt(pars$sig2/(2*pars$alpha))\n    if(type==\"lines\"){\n      for(i in 1:pars$ntheta){\n        lines(c(OA[i,1],OA[i,2]),rep(pars$optima[i],2),col=cols[i],lwd=3)\n        lines(c(OA[i,1],OA[i,2]),rep(CIU95[i],2),col=cols[i],lwd=1.25,lty=2)\n        lines(c(OA[i,1],OA[i,2]),rep(CIL95[i],2),col=cols[i],lwd=1.25,lty=2)\n      }\n    }\n    if(type==\"rect\"){\n      for(i in 1:pars$ntheta){\n        rect(OA[i,1],CIL95[i],OA[i,2],CIU95[i],col=cols[i],border=NA)\n      }\n    }\n    if(type==\"density\"){\n      ylim <- par('usr')[3:4]\n      for(i in 1:pars$ntheta){\n        x <- seq(OA[i,1],OA[i,2],length=10)\n        y <- seq(ylim[1],ylim[2],length=100)\n        Z <- matrix(nrow=length(x),ncol=length(y))\n        for(j in 1:length(x)){\n          Z[j,] <- dnorm(y,pars$optima[i],sqrt(pars$sig2/(2*pars$alpha)))\n        }\n        if(sum(Z)!=0){\n          densregion(x,y,Z,colmax=makeTransparent(cols[i],alpha),colmin=\"transparent\")\n        }\n        lines(c(OA[i,1],OA[i,2]),rep(pars$optima[i],2),col=cols[i],lwd=2)\n      }\n    }\n  }\n\nphenogram.density <- function(tree,data,post.samp,chains,K=NULL,cols=cols,fcols=NULL,fsize=0.5,ftype=\"reg\",xadj=0,...){\n  #tree$maps <- NULL\n  opt <- lapply(chains,function(x) x$optima[post.samp])\n  no.opt <- lapply(opt,function(x) sapply(x,length))\n  min.opt <- min(unlist(opt))\n  max.opt <- max(unlist(opt))\n  if(is.null(K)){\n    K <- unique(unlist(no.opt))\n  }\n  nH <- max(nodeHeights(tree))\n  plot(c(0,nH+0.3*nH),c(min(dat)-0.25,max(dat)+0.25),type='n',xlab=\"Time\",ylab=\"Phenotype\")\n  phenogram(tree,dat,colors=cols,fsize=fsize,ftype=ftype,add=TRUE,fcols=fcols,xadj=xadj)\n  dens.opt <- lapply(1:length(opt),function(x) density(unlist(opt[[x]][no.opt[[x]] %in% K]),...))\n  tmp <- sapply(1:length(dens.opt),function(Q){lines(nH+dens.opt[[Q]]$y*(0.3*nH)/max(dens.opt[[Q]]$y),dens.opt[[Q]]$x,col=Q+1)})\n}\n\n.priorSim <- function(.prior,tree,model,plot=TRUE,nsim=1,exclude.branches=NULL){\n  tree <- reorder(tree,'postorder')\n  model <- attributes(.prior)$model\n  dists <- attributes(.prior)$dist\n  prior.params <- attributes(.prior)$param\n  rdists <- lapply(dists,function(x) gsub('^[a-zA-Z]',\"r\",x))\n  prior.params <- lapply(prior.params,function(x) x[-which(names(x)==\"log\")])\n  rdists.fx <- lapply(rdists,get)\n  rdists.fx <- lapply(1:length(rdists.fx),function(x) set.defaults(rdists.fx[[x]],defaults=prior.params[[x]]))\n  names(rdists.fx) <- gsub('^[a-zA-Z]',\"r\",names(rdists))\n  N <- sapply(names(rdists.fx),function(x) switch(x,ralpha=nsim,rsig2=nsim, rsig2jump=nsim,rhalflife=nsim,rVy=nsim,rh2=nsim,rP=nsim,rw2=nsim,rNe=nsim,rk=nsim,rtheta=NULL,rloc=NULL,rsb=NULL))\n  varN <- which(sapply(N,is.null))\n  N <- N[-varN]\n  simpar <- lapply(1:nsim,function(i){ y <- lapply(names(N), function(x) rdists.fx[[x]](1)); names(y) <- gsub('^[a-zA-Z]',\"\",names(N)); y})\n  if(model %in% c(\"OUcpp\",\"QGcpp\",\"OUreparcpp\")){\n    T <- sum(tree$edge.length[!(1:length(tree$edge.length) %in% exclude.branches)])\n    pp <- tree$edge.length/T\n    pp[1:length(pp) %in% exclude.branches] <- 0\n    k <- lapply(simpar,function(x) x$k)\n    sb <- lapply(k,function(x) sample(1:length(tree$edge.length),x,replace=TRUE,prob=pp))\n    loc <- lapply(sb,function(x) runif(length(x),min=0,max=tree$edge.length[x]))\n    t2 <- lapply(k,function(x) 2:(x+1))\n    simpar <- lapply(1:nsim,function(x) c(simpar[[x]],list(sb=sb[[x]],loc=loc[[x]],t2=t2[[x]])))\n    theta <- lapply(1:nsim,function(x) pars2simmap(simpar[[x]],tree,sim.theta=TRUE,root.theta=rdists.fx$rtheta(1))$pars$theta)\n    simpar <- lapply(1:nsim, function(x) c(simpar[[x]],list(theta=theta[[x]],ntheta=length(theta[[x]]))))\n  }\n  if(model %in% c(\"OU\",\"QG\",\"OUrepar\")){\n    k <- sapply(simpar,function(x) x$k)\n    sb <- lapply(k,function(x) sample(1:length(tree$edge.length),x,replace=FALSE))\n    loc <- lapply(sb,function(x) runif(length(x),min=0,max=tree$edge.length[x]))\n    t2 <- lapply(k,function(x) 2:(x+1))\n    theta <- lapply(k,function(x) rdists.fx$rtheta(x+1))\n    simpar <- lapply(1:nsim,function(x) c(simpar[[x]],list(theta=theta[[x]],sb=sb[[x]],loc=loc[[x]],t2=t2[[x]])))\n  }\n  if(plot){\n    if(nsim>1){\n      par(ask=TRUE)\n    }\n    for(i in 1:nsim){\n      maps <- pars2simmap(simpar[[i]],tree,sim.theta=FALSE,theta=simpar[[i]]$theta)\n      tree$maps <- maps$tree$maps\n      col <- maps$col\n      plotSimmap(tree,colors=col)\n    }\n\n  }\n  return(list(pars=simpar,tree=tree))\n}\n                    \n",
    "created" : 1379457050453.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3014391503",
    "id" : "A44A7E18",
    "lastKnownWriteTime" : 1378755327,
    "path" : "~/BayesOUFit/BayOU0.1/BayOU0.2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}