{
    "contents" : ".proposalFn <- function(u,ct,D,moves,cache,oldpar){\n  ct <- .updateControl(ct,oldpar)\n  ctM <-ct[sapply(ct,length)==1]\n  move <- names(ct)[u < cumsum(unlist(ctM))][1]\n  .moveFn <- get(moves[[move]])\n  prop <- .moveFn(move=move,ct=ct,pars=oldpar,cache=cache,d=D[[move]])\n  return(list(prop=prop,move=move,u=u))\n}\n\n\n.splitmerge.emap <- function(emap,pars,cache,plim=plim,d,move=NULL){\n  j <- round(runif(1,0.5,2*cache$ntips-2+0.5),0)\n  emap.new <- emap\n  pars.new <- pars\n  b <- dim(emap)[1]\n  if(emap$sh[j]==1){\n    decision <- \"death\"\n    emap.new$sh[j] <- 0\n    emap.new$r1[j] <- emap.new$r[j]\n    emap.new$r2[j] <- 0\n    old.t <- emap.new$t2[j]\n    new.t <- emap.new$t1[j]\n    t1W <- sum(emap.new$r1[emap.new$t1==new.t]+emap.new$r2[emap.new$t1==new.t])\n    t2W <- sum(emap.new$r1[emap.new$t2==old.t]+emap.new$r2[emap.new$t2==old.t])\n    r <- t2W/(t1W+t2W)\n    emap.new$t1[emap.new$t1==old.t] <- new.t\n    emap.new$t2[emap.new$t2==old.t] <- new.t\n    if(sum(emap.new$t1>old.t)>0){\n      emap.new$t1[emap.new$t1>old.t] <-  emap.new$t1[emap.new$t1>old.t]-1\n    }\n    if(sum(emap.new$t2>old.t)>0){\n      emap.new$t2[emap.new$t2>old.t] <-  emap.new$t2[emap.new$t2>old.t]-1\n    }\n    pars.new$optima[new.t] <- (1-r)*pars.new$optima[new.t]+(r)*pars.new$optima[old.t]\n    pars.new$optima <- pars.new$optima[-old.t]\n    pars.new$ntheta <- pars$ntheta-1\n    pars.new$nb <- pars$nb-1\n    hr <- ifelse(pars.new$nb==pars$nb-1,log(1/d),log(0))\n  }\n  if(emap$sh[j]==0){\n    decision <- \"birth\"\n    emap.new$sh[j] <- 1\n    emap.new$t2[j] <- pars$ntheta+1\n    u <- runif(1)\n    emap.new$r1[j] <- u*emap.new$r[j]\n    emap.new$r2[j] <- (1-u)*emap.new$r[j]\n    pars.new$ntheta <- pars$ntheta+1\n    pars.new$nb <- pars$nb+1\n    t1W <- sum(emap.new$r1[emap.new$t1==emap.new$t1[j]]+emap.new$r2[emap.new$t1==emap.new$t1[j]])\n    t2W <- sum(emap.new$r1[emap.new$t2==emap.new$t2[j]]+emap.new$r2[emap.new$t2==emap.new$t2[j]])\n    r <- t2W/(t1W+t2W)\n    u <- runif(1,-0.5,0.5)*d\n    pars.new$optima[emap.new$t1[j]] <- pars$optima[emap.new$t1[j]]-u*r\n    pars.new$optima[emap.new$t2[j]] <- pars$optima[emap.new$t1[j]]+u*(1-r)   \n    if(emap.new$e2[j]>cache$ntips){\n      nopt <- rep(1,b)\n      nopt[emap.new$e2] <- emap.new$t2\n      for(i in (j-1):1){\n        if(emap.new$sh[i]==0){\n          nopt[emap.new$e2[i]] <- nopt[emap.new$e1[i]]\n        }\n      }\n      emap.new$t1 <- nopt[emap.new$e1]\n      emap.new$t2 <- nopt[emap.new$e2]\n    }\n    hr <-  ifelse(pars.new$nb==pars$nb+1,log(d),log(0))\n  }\n  list(pars=pars.new,emap=emap.new,decision=decision,branch=j,hr=hr)\n}\n\naddshift2map <- function(x,maps=maps,sb=sb,loc=loc,t2=t2){\n  m <- maps[[sb[x]]]\n  cs.m <- cumsum(m)\n  o <- min(which(cs.m>loc[x]))\n  if(o==1){\n    m[o] <- loc[x]\n  } else {\n    m[o] <- loc[x]-cs.m[o-1]\n  }\n  new.m <- cs.m[o]-loc[x]\n  names(new.m) <- t2[x]\n  M <- c(m[1:o],new.m,m[1:length(m) > o])\n  return(M)\n}\n\n#maps <- lapply(tree$edge.length,function(x){y <- x; names(y) <- 1; y})\n#maps[sb] <- lapply(1:pars$k,function(x){ y <- c(maps[[sb[x]]],loc[x]); names(y)[length(y)] <- t2[x]; y})\n.splitmergeSimmap <- function(pars,cache,ct,d,move=NULL,maps=NULL){\n  if(is.null(maps)){\n    maps <- pars2simmap(pars,cache$phy,sim.theta=FALSE,theta=pars$theta)$tree$maps\n  }\n  T <- sum(cache$edge.length)\n  v <- runif(1)\n  if(v < ct$bk[pars$k]/(ct$bk[pars$k]+ct$dk[pars$k])){\n    decision <- \"birth\"\n    sb.j <- sample(1:(2*ntips-2),1,prob=cache$edge.length/T)\n    loc.j <- runif(1,min=0,max=cache$edge.length[sb.j])\n    t2.j <- max(pars$t2)+1\n    maps.new <- maps\n    maps.new[[sb.j]] <- addshift2map(1,maps.new,sb.j,loc.j,t2.j)\n    t1 <- as.integer(names(maps.new[[sb.j]])[which(names(maps.new[[sb.j]])==t2.j)-1])\n    nopt <- rep(1,nbranch)\n    for(i in nbranch:1){\n      if(i %in% c(pars$sb,sb.j)){\n        opt <- as.integer(names(maps.new[[i]])[length(maps.new[[i]])])\n        nopt[tree$edge[i,2]] <- opt\n        names(maps.new[[i]])[1] <- nopt[tree$edge[i,1]]\n      } else {\n        names(maps.new[[i]])[1] <- nopt[tree$edge[i,1]] \n        nopt[tree$edge[i,2]] <- nopt[tree$edge[i,1]]\n      }\n    }\n    shiftdown <- nopt[tree$edge[,1]]\n    for(j in 1:nbranch){\n      names(maps.new[[j]])[1] <-shiftdown[j]\n    }\n    segs <- unlist(maps.new,FALSE,TRUE)\n    t2W <- sum(segs[names(segs)==t2.j])\n    t1W <- sum(segs[names(segs)==t1])\n    r <- t2W/(t1W+t2W)\n    u <- runif(1,-0.5,0.5)*d\n    pars.new <- pars\n    pars.new$theta[t1] <- pars$theta[t1]-u*r\n    pars.new$theta[t2.j] <- pars$theta[t1]+u*(1-r)   \n    pars.new$k <- pars$k+1\n    pars.new$ntheta <- pars$ntheta + 1\n    pars.new$sb <- c(pars$sb,sb.j)\n    pars.new$loc <- c(pars$loc,loc.j)\n    pars.new$t2 <- c(pars$t2,t2.j)\n    hr <- log(ct$dk[pars.new$k]*T*d)-log(ct$bk[pars$k]*pars.new$k)\n  } else {\n    decision <- \"death\"\n    j <- sample(1:pars$k,1)\n    pars.new <- pars\n    pars.new$k <- pars$k-1\n    pars.new$ntheta <- pars$ntheta-1\n    pars.new$sb <- pars$sb[-j]\n    pars.new$loc <- pars$loc[-j]\n    pars.new$t2 <- pars$t2[-pars$k]\n    pars.new$theta <- pars$theta[-(j+1)]\n    t2 <- pars$t2[j]\n    t1 <- as.integer(names(maps[[pars$sb[j]]])[which(names(maps[[pars$sb[j]]])==t2)-1])\n    segs <- unlist(maps,FALSE,TRUE)\n    t2W <- sum(segs[names(segs)==t2])\n    t1W <- sum(segs[names(segs)==t1])\n    r <- t2W/(t1W+t2W)\n    pars.new$theta[t1-(t1>t2)] <- pars$theta[t1]*(1-r)+pars$theta[t2]*r\n    hr <- log(ct$bk[pars.new$k]*pars.new$k)-log(ct$dk[pars$k]*T*d)\n    maps.new <- pars2simmap(pars.new,cache$phy,sim.theta=FALSE,theta=pars.new$theta)$tree$maps\n  }\n  cache$maps <- maps.new\n  return(list(pars=pars.new,cache=cache,decision=decision,hr=hr))\n}\n\n\n###Generic multiplier proposal\n.multiplierProposal <- function(move,cache,pars,d,ct=NULL){\n  m <- exp(d*(runif(1)-0.5))\n  prop <- pars[[move]]*m\n  lnHastingsRatio <- log(m)\n  pars.new <- pars\n  pars.new[[move]] <- prop\n  #prior1 <- .prior(pars,emap,cache)\n  #prior2 <- .prior(pars.new,emap,cache)\n  return(list(\"pars\"=pars.new,\"cache\"=cache,\"par\"=ifelse(class(move)==\"numeric\",names(pars)[move],move),\"hr\"=lnHastingsRatio))\n}\n\n##Adjust a randomly selected theta parameter\n.adjustTheta <- function(cache, pars, d, type=\"slidingwindow\",move=NULL,ct=NULL){\n  j <- sample(1:pars$ntheta,1)\n  if(type==\"slidingwindow\"){\n    ##Generate sliding-window proposal\n    prop <- d*(runif(1)-0.5)+pars$theta[j]\n    lnHastingsRatio <- 0\n    pars.new <- pars\n    pars.new$theta[j] <- prop\n    #pr <- .prior(pars.new,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"optima\" = j, \"prop\" = prop, \"hr\"=lnHastingsRatio,  \"pars\" = pars.new,\"cache\"=cache))\n  }\n  if(type==\"multiplier\"){\n    ##Generate multiplier proposal\n    m <- exp(d*(runif(1)-0.5))\n    prop <- pars$theta[j]*m\n    lnHastingsRatio <- log(m)\n    pars.new <- pars\n    pars.new$theta[j] <- prop\n    #pr <- .prior(pars.new,emap,cache)-.prior(pars,emap,cache)\n    return(list(\"theta\" = j, \"prop\" = prop, \"hr\"=lnHastingsRatio, \"pars\" = pars.new,\"cache\"=cache))\n  }\n}\n\n\n\n###Internal function for calculating the allowable space surrounding a shift for a slide move. Moves can only occur within a branch, or to immediately adjacent neighboring branches. Furthermore, a shift cannot be moved past another preexisting shift, and is also constrained by the tips and the root of the tree. If a shift moves within a branch, the proposal ratio is 1. If it shifts from one branch to a neighboring branch, however, it will change because the allowable space for that move will change.\n.slidespace <- function(j,cache,pars){\n  m <- cache$maps[[pars$sb[j]]]\n  t2 <- pars$t2[j]\n  nodes <- cache$edge[pars$sb[j],]\n  U0 <- unname(m[names(m)==t2])\n  D0 <- unname(m[which(names(m)==t2)-1])\n  if(which(names(m)==t2)==length(m) & nodes[2] > cache$ntips){\n    sbU <- which(cache$edge[,1]==nodes[2])\n    mU <- cache$maps[sbU]\n    U1 <- unname(mU[[1]][1])\n    U2 <- unname(mU[[2]][1])\n  } else {\n    sbU <- c(0,0)\n    U1 <- 0\n    U2 <- 0\n  }\n  if(which(names(m)==t2)<3 & nodes[1]!=cache$ntips+1){\n    sbD <- unname(which(tree$edge[,2]==nodes[1]))\n    mD <- cache$maps[[sbD]]\n    D1 <- unname(mD[length(mD)])\n  } else {D1 <- 0; sbD <- 0}\n  sbj <- c(U0=pars$sb[j],D0=pars$sb[j],U1=sbU[1],U2=sbU[2],D1=sbD)\n  return(list(sb=sbj,pp=c(U0=U0,D0=D0,U1=U1,U2=U2,D1=D1)))\n}\n\n.slideCPP <- function(cache,pars,d,move=NULL,ct=NULL){\n  j <- sample(1:pars$k,1)\n  t2 <- pars$t2[j]\n  space <- .slidespace(j,cache,pars)\n  mv <- sample(1:5,1,prob=space$pp/sum(space$pp))\n  type <- names(space$sb)[mv]\n  l <- runif(1,0,space$pp[type])\n  maps.new <- cache$maps\n  pars.new <- pars\n  if(type==\"U0\"){\n    m <- cache$maps[[space$sb[mv]]]\n    m[which(names(m)==t2)-1] <- m[which(names(m)==t2)-1] + (m[names(m)==t2]-l)\n    m[names(m)==t2] <- l\n    maps.new[[space$sb[mv]]] <- m\n    cs.m <- cumsum(m)\n    pars.new$loc[j] <- unname(cs.m[which(names(cs.m)==t2)-1])\n  } else {\n    if(type==\"D0\"){\n      m <- cache$maps[[space$sb[mv]]]\n      m[names(m)==t2] <- (m[which(names(m)==t2)-1]-l)+m[names(m)==t2]\n      m[which(names(m)==t2)-1] <- l\n      maps.new[[space$sb[mv]]] <- m\n      cs.m <- cumsum(m)\n      pars.new$loc[j] <- unname(cs.m[which(names(cs.m)==t2)-1])\n    } else {\n      pars.new$sb[j] <- space$sb[mv]\n      if(type %in% c(\"U1\",\"U2\")){\n        m0 <- cache$maps[[pars$sb[j]]]\n        t1 <- names(m0)[which(names(m0)==t2)-1]\n        m0[length(m0)-1] <- m0[length(m0)-1]+m0[length(m0)]\n        m0 <- m0[-length(m0)]\n        m <- cache$maps[[space$sb[mv]]]\n        m <- c(l,m[1]-l,m[-1])\n        names(m)[1] <- t1\n        maps.new[[space$sb[mv]]] <- m\n        maps.new[[pars$sb[j]]] <- m0\n        cs.m <- cumsum(m)\n        pars.new$loc[j] <- unname(cs.m[which(names(cs.m)==t2)-1])\n      } else {\n        if(type==\"D1\"){\n          m0 <- cache$maps[[pars$sb[j]]]\n          t1 <- names(m0)[which(names(m0)==t2)-1]\n          m0[2] <- m0[2]+m0[1]\n          m0 <- m0[-1]\n          m <- cache$maps[[space$sb[mv]]]\n          m <- c(m[-length(m)],m[length(m)]-l,l)\n          names(m)[length(m)] <- t2\n          maps.new[[space$sb[mv]]] <- m\n          maps.new[[pars$sb[j]]] <- m0\n          cs.m <- cumsum(m)\n          pars.new$loc[j] <- unname(cs.m[which(names(cs.m)==t2)-1])\n        }\n      }\n      maps.new <- pars2simmap(pars.new,cache$phy,sim.theta=FALSE,theta=pars.new$theta)$tree$maps\n    }\n  }\n  cache$maps <- maps.new\n  new.space <- .slidespace(j,cache,pars.new)\n  hr <- log(1/sum(new.space$pp))-log(1/(sum(space$pp)))\n  return(list(pars=pars.new,cache=cache,hr=hr))\n}\n\n#'MCMC move for splitting or collapsing a shift on phylogeny\n.splitmerge <- function(pars, cache, ct,d,move=NULL){\n  nbranch <- length(cache$edge.length)\n  TH <- sum(cache$edge.length)\n  v <- runif(1)\n  sb.max <- ct$sb$bmax\n  sb.taken <- rep(0,2*cache$ntips-2)\n  sb.table <- table(pars$sb)\n  sb.taken[as.numeric(names(sb.table))] <- sb.table\n  sb.prob <- ct$sb$prob\n  sb.prob[sb.max <= sb.taken] <- 0\n  if(v < ct$bk[pars$k]/(ct$bk[pars$k]+ct$dk[pars$k])){\n    decision <- \"birth\"\n    sb.j <- sample(1:(2*cache$ntips-2),1,prob=sb.prob)\n    loc.j <- runif(1,min=0,max=cache$edge.length[sb.j])\n    t2.j <- max(pars$t2)+1\n    pars.new <- pars\n    pars.new$sb <- c(pars$sb, sb.j)\n    pars.new$loc <- c(pars$loc, loc.j)\n    pars.new$t2 <- c(pars$t2, t2.j)\n    map.new <- .pars2map(pars.new, cache)\n    t1 <- map.new$theta[max(which(map.new$theta==t2.j))+1]\n    t2W <- sum(map.new$segs[map.new$theta==t2.j])\n    t1W <- sum(map.new$segs[map.new$theta==t1])\n    r <- t2W/(t1W+t2W)\n    u <- runif(1,-0.5,0.5)*d\n    pars.new$theta[t1] <- pars$theta[t1]-u*r\n    pars.new$theta[t2.j] <- pars$theta[t1]+u*(1-r)   \n    pars.new$k <- pars$k+1\n    pars.new$ntheta <- pars$ntheta + 1\n    pars.new$sb <- c(pars$sb,sb.j)\n    pars.new$loc <- c(pars$loc,loc.j)\n    pars.new$t2 <- c(pars$t2,t2.j)\n    hr <- log(ct$dk[pars.new$k]*1/pars.new$k*d)-log(ct$bk[pars$k]*sb.prob[sb.j]/sum(sb.prob))\n  } else {\n    decision <- \"death\"\n    j <- sample(1:pars$k,1)\n    pars.new <- pars\n    pars.new$k <- pars$k-1\n    pars.new$ntheta <- pars$ntheta-1\n    pars.new$sb <- pars$sb[-j]\n    pars.new$loc <- pars$loc[-j]\n    pars.new$t2 <- pars$t2[-pars$k]\n    pars.new$theta <- pars$theta[-(j+1)]\n    map <- .pars2map(pars, cache)\n    t2.j <- pars$t2[j]\n    sb.j <- pars$sb[j]\n    t1 <- map$theta[max(which(map$theta==t2.j))-1]\n    t2W <- sum(map$segs[map$theta==t2.j])\n    t1W <- sum(map$segs[map$theta==t1])\n    r <- t2W/(t1W+t2W)\n    pars.new$theta[t1-(t1>t2.j)] <- pars$theta[t1]*(1-r)+pars$theta[t2.j]*r\n    hr <- log(ct$bk[pars.new$k]*sb.prob[sb.j]/sum(sb.prob))-log(ct$dk[pars$k]*1/pars$k*d)\n  }\n  return(list(pars=pars.new, decision=decision,hr=hr))\n}\n#.add2map <- function(map, cache, pars, sb.j, loc.j, t2.j){\n#    j <- which(names(map$segs)==sb.j)\n#    m <- map$segs[j]\n#    new.m <- c(m,loc.j)\n#    o <- order(new.m)\n#    new.m <- new.m[o]\n#    names(new.m) <- rep(sb.j,length(o))\n#    t2 <- map$theta[j]\n#    o.t2 <- which(o==length(o))\n#    new.t2 <- c(t2[1:o.t2],t2.j)\n#    if(o.t2 != length(t2)){\n#      new.t2 <- c(new.t2, t2[(o.t2+1):(length(t2))])\n#    }\n#    names(new.t2) <- rep(sb.j,length(o))\n#    new.segs <- c(map$segs[1:(min(j)-1)], new.m)\n#    new.theta <- c(map$theta[1:(min(j)-1)], new.t2)\n#    if(length(new.segs)!=(length(map$segs)+1)){\n#      new.segs <- c(new.segs, map$segs[(max(j)+1):length(map$segs)])\n#      new.theta <- c(new.theta, map$theta[(max(j)+1):length(map$segs)])\n#    }\n#    if(o.t2 == length(t2)){\n#      desc <- cache$bdesc[sb.j][[1]]\n#      desc.desc.sb <- cache$bdesc[pars$sb[pars$sb %in% desc]]\n##      relabel <- setdiff(desc,unlist(desc.desc.sb,F,F))\n#        new.theta[as.character(relabel)] <- t2.j\n#      }\n#    }\n # return(list(segs=new.segs, theta=new.theta))\n#}\n",
    "created" : 1379439047609.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "243704328",
    "id" : "5CA58525",
    "lastKnownWriteTime" : 1380157461,
    "path" : "~/repos/bayou/bayou_1.0/R/bayou-moves.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}