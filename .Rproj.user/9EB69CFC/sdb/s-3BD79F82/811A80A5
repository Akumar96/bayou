{
    "contents" : "#' bayOU internal function. \n#' \n#' \\code{.fix.root.bm} is an internal function and not generally called by the user\n#' \n#' This is an internal function from geiger.\n.fix.root.bm <- geiger:::.fix.root.bm\n\n#' bayOU internal function. \n#' \n#' \\code{.ou.cache} is an internal function and not generally called by the user\n#' \n#' This is an internal function that modifies the internal function \\code{.ou.cache} in geiger for efficiency.\n.ou.cache.fast <- function (cache) \n{\n  ht = cache$ht\n  N = cache$n.tip\n  Tmax = ht$start[N + 1]\n  mm = match(1:nrow(ht), cache$edge[, 2])\n  ht$t1 = Tmax - ht$end[cache$edge[mm, 1]]\n  ht$t2 = ht$start - ht$end + ht$t1\n  z = function(alpha) {\n    if (alpha < 0) \n      stop(\"'alpha' must be positive valued\")\n    bl = (1/(2 * alpha)) * exp(-2 * alpha * (Tmax - ht$t2)) * \n      (1 - exp(-2 * alpha * ht$t2)) - (1/(2 * alpha)) * \n      exp(-2 * alpha * (Tmax - ht$t1)) * (1 - exp(-2 * \n                                                    alpha * ht$t1))\n    cache$len = bl\n    cache\n  }\n  attr(z, \"argn\") = \"alpha\"\n  return(z)\n}\n#' bayOU internal function. \n#' \n#' \\code{fastbm.lik} is an internal function and not generally called by the user\n#' \n#' This is an internal function that modifies the internal function \\code{bm.lik} in geiger for efficiency.\n.fastbm.lik <- function (phy, dat, ht,SE = NA, model = c(\"BM\", \"OU\", \"EB\", \"trend\", \n                                       \"lambda\", \"kappa\", \"delta\", \"drift\", \"white\"), ...) {\n  model = match.arg(model, c(\"BM\", \"OU\", \"EB\", \"trend\", \"lambda\", \n                             \"kappa\", \"delta\", \"drift\", \"white\"))\n  cache = .prepare.bm.univariate(phy, dat, SE = SE, ...)\n  cache$ht <- ht\n  cache$ordering = attributes(cache$phy)$order\n  cache$N = cache$n.tip\n  cache$n = cache$n.node\n  cache$nn = (cache$root + 1):(cache$N + cache$n)\n  cache$intorder = as.integer(cache$order[-length(cache$order)])\n  cache$tiporder = as.integer(1:cache$N)\n  cache$z = length(cache$len)\n  FUN = switch(model, BM = .null.cache(cache), OU = .ou.cache.fast(cache), \n               EB = .eb.cache(cache), trend = .trend.cache(cache), lambda = .lambda.cache(cache), \n               kappa = .kappa.cache(cache), delta = .delta.cache(cache), \n               drift = .null.cache(cache), white = .white.cache(cache))\n  ll.bm.direct = function(cache, sigsq, q = NULL, drift = NULL, \n                          se = NULL) {\n    n.cache = cache\n    given = attr(n.cache$y, \"given\")\n    if (is.null(q)) {\n      llf = FUN()\n    }\n    else {\n      llf = FUN(q)\n    }\n    ll = llf$len\n    dd = 0\n    if (!is.null(drift)) \n      dd = drift\n    adjvar = as.integer(attr(n.cache$y, \"adjse\"))\n    adjSE = any(adjvar == 1)\n    .xxSE = function(cache) {\n      vv = cache$y[\"s\", ]^2\n      ff = function(x) {\n        if (any(ww <- adjvar == 1)) {\n          vv[which(ww)] = x^2\n          return(vv)\n        }\n        else {\n          return(vv)\n        }\n      }\n      return(ff)\n    }\n    modSE = .xxSE(n.cache)\n    vv = as.numeric(modSE(se))\n    datC = list(len = as.numeric(ll), intorder = as.integer(n.cache$intorder), \n                tiporder = as.integer(n.cache$tiporder), root = as.integer(n.cache$root), \n                y = as.numeric(n.cache$y[\"m\", ]), var = as.numeric(vv), \n                n = as.integer(n.cache$z), given = as.integer(given), \n                descRight = as.integer(n.cache$children[, 1]), descLeft = as.integer(n.cache$children[, \n                                                                                                      2]), drift = as.numeric(dd))\n    parsC = as.numeric(rep(sigsq, n.cache$z))\n    out = .Call(\"bm_direct\", dat = datC, pars = parsC, package = \"geiger\")\n    loglik <- sum(out$lq)\n    if (is.na(loglik)) \n      loglik = -Inf\n    attr(loglik, \"ROOT.MAX\") = out$initM[datC$root]\n    class(loglik) = c(\"glnL\", class(loglik))\n    return(loglik)\n  }\n  class(ll.bm.direct) <- c(\"bm\", \"dtlik\", \"function\")\n  fx_exporter = function() {\n    attb = c()\n    if (!is.null(qq <- argn(FUN))) {\n      adjQ = TRUE\n      attb = c(attb, qq)\n    }\n    else {\n      adjQ = FALSE\n    }\n    attb = c(attb, \"sigsq\")\n    if (any(attr(cache$y, \"adjse\") == 1)) {\n      attb = c(attb, \"SE\")\n    }\n    if (model == \"drift\") {\n      attb = c(attb, \"drift\")\n    }\n    cache$attb = attb\n    lik <- function(pars, ...) {\n      recache = function(nodes = NULL, root = ROOT.MAX, \n                         cache) {\n        r.cache = cache\n        if (root == ROOT.MAX) {\n          rtmx = TRUE\n        }\n        else if (root %in% c(ROOT.OBS, ROOT.GIVEN)) {\n          rtmx = FALSE\n          r.cache$attb = c(cache$attb, \"z0\")\n        }\n        else {\n          stop(\"unusable 'root' type specified\")\n        }\n        r.cache$ROOT.MAX = rtmx\n        if (!is.null(nodes)) {\n          m = r.cache$y[\"m\", ]\n          s = r.cache$y[\"s\", ]\n          g = attr(r.cache$y, \"given\")\n          nn = r.cache$nn\n          r.cache$y = .cache.y.nodes(m, s, g, nn, r.cache$phy, \n                                     nodes = nodes)\n        }\n        r.cache\n      }\n      rcache = recache(..., cache = cache)\n      attb = rcache$attb\n      if (missing(pars)) \n        stop(paste(\"The following 'pars' are expected:\\n\\t\", \n                   paste(attb, collapse = \"\\n\\t\", sep = \"\"), sep = \"\"))\n      pars = .repars(pars, attb)\n      names(pars) = attb\n      if (adjQ) \n        q = pars[[qq]]\n      else q = NULL\n      sigsq = pars[[\"sigsq\"]]\n      if (\"SE\" %in% attb) \n        se = pars[[\"SE\"]]\n      else se = NULL\n      if (\"drift\" %in% attb) \n        drift = -pars[[\"drift\"]]\n      else drift = 0\n      if (\"z0\" %in% attb) \n        rcache = .fix.root.bm(pars[[\"z0\"]], rcache)\n      ll = ll.bm.direct(cache = rcache, sigsq = sigsq, \n                        q = q, drift = drift, se = se)\n      return(ll)\n    }\n    attr(lik, \"argn\") = attb\n    attr(lik, \"cache\") <- cache\n    class(lik) = c(\"bm\", \"function\")\n    lik\n  }\n  likfx = fx_exporter()\n  return(likfx)\n}\n\n#' bayOU internal function. \n#' \n#' \\code{.emOU.lik} is an internal function and not generally called by the user\n#' \n#' This is an internal function that calculates the likelihood of a multioptima OU model.\n.emOU.lik <- function(pars,emap,cache,X,SE=0,model=\"OU\",fast=TRUE){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  TotExp=exp(-cache$height*pars$alpha)\n  W <- .edgemap.W(cache,pars,emap,TotExp)\n  if(pars$ntheta>1){\n    E.th=W%*%pars$theta\n  } else {E.th=W*pars$theta}\n  X.c<-X-as.vector(E.th)\n  if(fast){\n    lnL.fx<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n    #lnL.fx<-bm.lik(cache$phy,X.c,SE=NA,model=\"OU\")\n    loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  } else {\n    lnL.fx <- bm.lik(cache$phy,X.c,SE=TRUE,model=\"OU\")\n    loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  }\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th)\n}\n\nemOU.lik <- function(pars,emap,tree,X,SE=0, method=\"pruning\",model=\"OU\"){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  if(class(tree)==\"phylo\"){\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  TotExp=exp(-cache$height*pars$alpha)\n  W <- .edgemap.W(cache,pars,emap,TotExp,X)\n  E.th=as.matrix(W)%*%pars$theta\n  if(method==\"pruning\"){system.time({\n    ##Convert the data into residuals from the expected values\n    X.c<-X-as.vector(E.th)\n    ##Make the pruning algorithm function for a single-optimum OU model\n    lnL<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=c(\"OU\"))\n    ##Call the pruning algorithm function we just made\n    loglik=lnL(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  })->time}\n  if(method==\"invert\"){system.time({\n    ##Standard calculation of the likelihood by inverting the VCV matrix\n    ouMatrix <- function(vcvMatrix, alpha)\n    {  vcvDiag<-diag(vcvMatrix)\n       diagi<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag))\n       diagj<-matrix(vcvDiag, nrow=length(vcvDiag), ncol=length(vcvDiag), byrow=T)\n       Tij = diagi + diagj - (2 * vcvMatrix)\n       vcvRescaled = (1 / (2 * alpha)) * exp(-alpha * Tij) * (1 - exp(-2 * alpha * vcvMatrix))\n       return(vcvRescaled)\n    }\n    Sigma <- ouMatrix(vcv.phylo(cache$phy),pars$alpha)*pars$sig2\n    diag(Sigma) <- diag(Sigma)+SE^2\n    X.c <- X-as.vector(E.th)\n    loglik <- dmnorm(as.vector(X.c),rep(0,length(X.c)),Sigma,log=TRUE)\n  })->time}\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th,time=time)\n}\n\n#' Calculate the likelihood of a multi-optima OU model from simmap format regimes\n#' \n#' Calculates the likelihood of an OU model with regimes stored in tree$maps. \n#' \n#' @rdname sdOU.lik\n#' \nsmOU.lik <- function(pars,tree,X,SE=0,model=\"OU\"){\n  if(class(tree)==\"phylo\"){\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  W <- .simmap.W(cache,pars)\n  if(pars$ntheta>1){\n    E.th <- W%*%pars$theta\n  } else {E.th <- W*pars$theta}\n  X.c<-X-as.vector(E.th)\n  lnL.fx<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n  #lnL.fx<-bm.lik(cache$phy,X.c,SE=NA,model=\"OU\")\n  loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th)\n}\n\n#' \n#' \n.smOU.lik <- function(pars,cache,X,SE=0,model=\"OU\"){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  W <- .simmap.W(cache,pars)\n  if(pars$ntheta>1){\n    E.th=W%*%pars$theta\n  } else {E.th=W*pars$theta}\n  X.c<-X-as.vector(E.th)\n  lnL.fx<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n  loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th)\n}\n\n#' Calculate the likelihood of a multi-optima OU model from parameter list that includes shifts branches (sb),\n#' shift locations (loc) and shift optima (t2)\n#' \n#' Calculates the likelihood of an OU model with regimes specified by a parameter list\n#' \n#' @rdname sdOU.lik\n#' \nOU.lik <- function(pars,tree,X,SE=0,model=\"OU\"){\n  if(class(tree)==\"phylo\"){\n    cache <- .prepare.ou.univariate(tree,X)\n  } else {cache <- tree}\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  W <- .parmap.W(cache,pars)\n  if(pars$ntheta>1){\n    E.th <- W%*%pars$theta\n  } else {E.th <- W*pars$theta}\n  X.c<-X-as.vector(E.th)\n  lnL.fx<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n  #lnL.fx<-bm.lik(cache$phy,X.c,SE=NA,model=\"OU\")\n  loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th)\n}\n\n#' \n#' \n.OU.lik <- function(pars,cache,X,SE=0,model=\"OU\"){\n  if(model==\"QG\"){\n    pars$alpha <- QG.alpha(pars)\n    pars$sig2 <- QG.sig2(pars)\n  }\n  if(model==\"OUrepar\"){\n    repar <- OU.repar(pars)\n    pars$alpha <- repar$alpha\n    pars$sig2 <- repar$sig2\n  }\n  W <- .parmap.W(cache,pars)\n  if(pars$ntheta>1){\n    E.th=W%*%pars$theta\n  } else {E.th=W*pars$theta}\n  X.c<-X-as.vector(E.th)\n  lnL.fx<-.fastbm.lik(cache$phy,X.c,cache$ht,SE=TRUE,model=\"OU\")\n  loglik <- lnL.fx(pars=c(pars$alpha,pars$sig2,SE,0),root=ROOT.GIVEN)\n  list(loglik=loglik,W=W,theta=pars$theta,resid=X.c,Exp=E.th)\n}",
    "created" : 1379982719697.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4018198536",
    "id" : "811A80A5",
    "lastKnownWriteTime" : 1380047871,
    "path" : "~/repos/bayou/bayou_1.0/R/bayou-likelihood.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}